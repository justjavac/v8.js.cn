<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Improving V8 regular expressions · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="In this blog post we describe how we take advantage of the upsides of interpreting regular expressions and mitigate the downsides." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Improving V8 regular expressions</h1><p class=meta>发布时间 <time datetime="2019-10-04 15:24:16" itemprop=datePublished title="2019-10-04 15:24:16">2019-10-04</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a> <a href=/blog/tags/regexp/ class=tag>RegExp</a></header><div itemprop=articleBody><p>In its default configuration, V8 compiles regular expressions to native code upon the first execution. As part of our work on <a href=/blog/jitless>JIT-less V8</a>, we introduced an interpreter for regular expressions. Interpreting regular expressions has the advantage of using less memory, but it comes with a performance penalty. In this blog post we describe how we take advantage of the upsides of interpreting regular expressions while mitigating the downsides.<h2 id=tier-up-strategy-for-regexp>Tier-up strategy for RegExp <a href=#tier-up-strategy-for-regexp class=bookmark>#</a></h2><p>We want to use the ‘best of both worlds’ for regular expressions. In order to do so, we first compile all regular expressions to bytecode and interpret them. This way, we save a lot of memory, and overall (and with the new, faster interpreter) the performance penalty is acceptable. If a regular expression with the same pattern is used again, we consider it to be ‘hot’ so we recompile to native code. From this point on, we continue the execution as fast as we can.<p>There are many different paths through the regular expression code in V8, depending on the method invoked, whether it is a global or non-global regexp, and if we’re taking the fast or slow path. That being said, we want the tier-up decision to be as centralized as possible. We’ve added a ticks field to V8’s RegExp object that is initialized to a certain value at runtime. This value represents the number of times the regular expression will be interpreted before we tier-up to the compiler. Each time the regular expression is interpreted, we decrement the ticks field by 1. In a built-in written in <a href=/blog/csa>CodeStubAssembler</a> which is invoked for all regular expressions, we check the ticks flag on every execution. Once the ticks reach 0, we know we need to recompile the regular expression to native code, and we jump to runtime to do so.<p>We’ve mentioned that regular expressions can have different execution paths. For the case of global replaces with functions as parameters, the implementations for native code and bytecode differ. The native code expects an array to store all matches upfront, and the bytecode matches one at a time. Because of this, we’ve decided to always eagerly tier-up to native code for this use case.<h2 id=speeding-up-the-regexp-interpreter>Speeding up the RegExp interpreter <a href=#speeding-up-the-regexp-interpreter class=bookmark>#</a></h2><h3 id=remove-runtime-overhead>Remove runtime overhead <a href=#remove-runtime-overhead class=bookmark>#</a></h3><p>When a regular expression is executed, a built-in written in <a href=/blog/csa>CodeStubAssembler</a> is invoked. This built-in previously checked if the JSRegExp object’s code field contained JITted native code that could be executed directly, and otherwise called a runtime method to compile (or interpret in JIT-less mode) the RegExp. In JIT-less mode, every execution of a regular expression went through the V8 runtime, which is quite expensive because we need to transition between JavaScript and C++ code on the execution stack.<p>Starting with V8 v7.8, whenever the RegExp compiler generates bytecode to interpret a regular expression, a trampoline to the RegExp interpreter is now stored in the JSRegExp object’s code field in addition to the generated bytecode. This way the interpreter now gets called from the built-in directly without a detour through the runtime.<h3 id=new-dispatch-method>New dispatch method <a href=#new-dispatch-method class=bookmark>#</a></h3><p>The RegExp interpreter previously used a simple <code>switch</code>-based dispatch method. The main disadvantage of this method is that the CPU has a very hard time predicting the next bytecode to execute, resulting in many branch mispredictions, slowing down execution.<p>We changed the dispatch method to threaded code in V8 v7.8. This method allows the CPU’s branch predictor to predict the next bytecode based on the currently executed bytecode, resulting in fewer mispredictions. In more detail, we use a dispatch table, storing a mapping between each bytecode ID and the address of the handler implementing the bytecode. V8’s interpreter <a href=/docs/ignition>Ignition</a> also uses this approach. However, a big difference between Ignition and the RegExp interpreter is that Ignition’s bytecode handlers are written in <a href=/blog/csa>CodeStubAssembler</a>, whereas the whole RegExp interpreter is written in C++ using <a href=https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html>computed <code>goto</code>s</a> (a GNU extension also supported by clang), which is easier to read and maintain than CSA. For compilers that don’t support computed gotos, we fall back to the old <code>switch</code>-based dispatch method.<h3 id=bytecode-peephole-optimization>Bytecode peephole optimization <a href=#bytecode-peephole-optimization class=bookmark>#</a></h3><p>Before we talk about bytecode peephole optimization, let’s look at a motivating example.<pre class=language-js><code class=language-js><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token language-regex regex-source">[^_]*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span><br><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'a0b*c_ef'</span><span class="token punctuation">;</span><br>re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → matches 'a0b*c'</span></code></pre><p>For this simple pattern, the RegExp compiler creates 3 bytecodes that are executed for every character. On a high level these are:<ol><li>Load current character.<li>Check if character equals <code>'_'</code>.<li>If not, advance current position in the subject string and <code>goto 1</code>.</ol><p>For our subject string we interpret 17 bytecodes until we find a non-matching character. The idea of peephole optimization is that we replace sequences of bytecodes with a new optimized bytecode that combines the functionality of multiple bytecodes. In our example we can even handle the implicit loop created by the <code>goto</code> explicitly in the new bytecode, thus a single bytecode handles all matching characters, saving 16 dispatches.<p>Although the example is made-up, the sequence of bytecodes described here occurs frequently in real-world websites. We analyzed <a href=/blog/real-world-performance>real websites</a> and created new optimized bytecodes for the most frequent bytecode sequences we encountered.<h2 id=results>Results <a href=#results class=bookmark>#</a></h2><figure><img alt="" height=371 loading=lazy src=/_img/regexp-tier-up/results-memory.svg width=600><figcaption>Figure 1: Memory savings for different tier-up values</figcaption></figure><p>Figure 1 shows the impact on memory of different tier-up strategies for Facebook, Reddit, Twitter and Tumblr browsing stories. The default is the size of JITted code, and then we have size of regexp code we end up using (bytecode size if we don’t tier-up, native code size if we do) for ticks initialized to 1, 10, and 100. Finally, we have the size of regexp code if we interpret all regular expressions. We’ve used these results and other benchmarks to decide to turn on the tier-up with ticks initialized to 1, i.e. we interpret the regular expression once, and then tier up.<p>With this tier-up strategy in place, we’ve reduced V8’s heap code size between 4 and 7% on real sites and V8’s effective size between 1 and 2%.<figure><img alt="" height=371 loading=lazy src=/_img/regexp-tier-up/results-speed.svg width=600><figcaption>Figure 2: RegExp performance comparison</figcaption></figure><p>Figure 2 shows the impact on the performance of the RegExp interpreter for all improvements described in this blog post<sup class=footnote-ref><a href=#fn1 id=fnref1>[1]</a></sup> on the RexBench benchmark suite. For reference, the performance of JIT compiled RegExp is also shown (Native).<p>The new interpreter is up to 2× as fast as the old one, averaging about 1.45× as fast. We even come quite close to the performance of JITted RegExp for most benchmarks, with Regex DNA being the only exception. The reason why interpreted RegExp are that much slower than JITted RegExp on this benchmark is due to the long subject strings (~300,000 characters) used. Even though we reduced dispatch overhead to a minimum, the overhead sums up on strings with more than 1,000 characters, resulting in slower execution. Because the interpreter is so much slower on long strings, we’ve added a heuristic that eagerly tiers-up for these strings.<h2 id=conclusion>Conclusion <a href=#conclusion class=bookmark>#</a></h2><p>Starting with V8 v7.9 (Chrome 79) we tier up regular expressions instead of eagerly compiling them. Therefore the interpreter, previously only used in JIT-less V8, is now used everywhere. As a result we save memory. We sped up the interpreter to make this feasible. But this is not the end of the story — more improvements can be expected in the future.<p>We would like to take this opportunity to thank everyone in the V8 team for their support during our internship. It was an awesome experience!<hr class=footnotes-sep><section class=footnotes><ol class=footnotes-list><li class=footnote-item id=fn1><p>The results shown here also include an improvement to regular expressions already described in the <a href=/blog/v8-release-78#faster-regexp-match-failures>V8 v7.8 release notes</a>. <a href=#fnref1 class=footnote-backref>↩︎</a></ol></section></div><footer><div><picture><source srcset="/_img/avatars/patrick-thier.avif, /_img/avatars/patrick-thier@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/patrick-thier.jpg width=96 srcset="/_img/avatars/patrick-thier@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/ana-pesko.avif, /_img/avatars/ana-pesko@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/ana-pesko.jpg width=96 srcset="/_img/avatars/ana-pesko@2x.jpg 2x"></picture><p>作者：Patrick Thier and Ana Peško, regular expressers of opinions about regular expressions.</div><a href=https://twitter.com/v8js/status/1180131710568030208 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/regexp-tier-up>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/regexp-tier-up.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
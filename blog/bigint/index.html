<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Adding BigInts to V8 · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="V8 now supports BigInts, a JavaScript language feature enabling arbitrary-precision integers." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Adding BigInts to V8</h1><p class=meta>发布时间 <time datetime="2018-05-02 13:33:37" itemprop=datePublished title="2018-05-02 13:33:37">2018-05-02</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a></header><div itemprop=articleBody><p>Over the past couple of months, we have implemented support for <a href=/features/bigint>BigInts</a> in V8, as currently specified by <a href=https://github.com/tc39/proposal-bigint>this proposal</a>, to be included in a future version of ECMAScript. The following post tells the story of our adventures.<h2 id=tl%3Bdr>TL;DR <a href=#tl%3Bdr class=bookmark>#</a></h2><p>As a JavaScript programmer, you now<sup class=footnote-ref><a href=#fn1 id=fnref1>[1]</a></sup> have integers with arbitrary<sup class=footnote-ref><a href=#fn2 id=fnref2>[2]</a></sup> precision in your toolbox:<pre class=language-js><code class=language-js><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">2172141653n</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">15346349309n</span><span class="token punctuation">;</span><br>a <span class="token operator">*</span> b<span class="token punctuation">;</span><br><span class="token comment">// → 33334444555566667777n     // Yay!</span><br><span class="token function">Number</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">Number</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → 33334444555566670000      // Boo!</span><br><span class="token keyword">const</span> such_many <span class="token operator">=</span> <span class="token number">2n</span> <span class="token operator">**</span> <span class="token number">222n</span><span class="token punctuation">;</span><br><span class="token comment">// → 6739986666787659948666753771754907668409286105635143120275902562304n</span></code></pre><p>For details about the new functionality and how it could be used, refer to <a href=/features/bigint>our in-depth article on BigInt</a>. We are looking forward to seeing the awesome things you’ll build with them!<h2 id=representing-bigints-in-memory>Representing BigInts in memory <a href=#representing-bigints-in-memory class=bookmark>#</a></h2><p>Typically, computers store integers in their CPU’s registers (which nowadays are usually 32 or 64 bits wide), or in register-sized chunks of memory. This leads to the minimum and maximum values you might be familiar with. For example, a 32-bit signed integer can hold values from -2,147,483,648 to 2,147,483,647. The idea of BigInts, however, is to not be restricted by such limits.<p>So how can one store a BigInt with a hundred, or a thousand, or a million bits? It can’t fit in a register, so we allocate an object in memory. We make it large enough to hold all the BigInt’s bits, in a series of chunks, which we call “digits” — because this is conceptually very similar to how one can write bigger numbers than “9” by using more digits, like in “10”; except where the decimal system uses digits from 0 to 9, our BigInts use digits from 0 to 4294967295 (i.e. <code>2**32-1</code>). That’s the value range of a 32-bit CPU register<sup class=footnote-ref><a href=#fn3 id=fnref3>[3]</a></sup>, without a sign bit; we store the sign bit separately. In pseudo-code, a <code>BigInt</code> object with <code>3*32 = 96</code> bits looks like this:<pre class=language-js><code class=language-js><span class="token punctuation">{</span><br>  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'BigInt'</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">sign</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">num_digits</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">digits</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0x12</span>…<span class="token punctuation">,</span> <span class="token number">0x34</span>…<span class="token punctuation">,</span> <span class="token number">0x56</span>…<span class="token punctuation">]</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span></code></pre><h2 id=back-to-school%2C-and-back-to-knuth>Back to school, and back to Knuth <a href=#back-to-school%2C-and-back-to-knuth class=bookmark>#</a></h2><p>Working with integers kept in CPU registers is really easy: to e.g. multiply two of them, there’s a machine instruction which software can use to tell the CPU “multiply the contents of these two registers!”, and the CPU will do it. For BigInt arithmetic, we have to come up with our own solution. Thankfully this particular task is something that quite literally every child at some point learns how to solve: remember what you did back in school when you had to multiply 345 * 678 and weren’t allowed to use a calculator?<pre><code>345 * 678
---------
     30    //   5 * 6
+   24     //  4  * 6
+  18      // 3   * 6
+     35   //   5 *  7
+    28    //  4  *  7
+   21     // 3   *  7
+      40  //   5 *   8
+     32   //  4  *   8
+    24    // 3   *   8
=========
   233910
</code></pre><p>That’s exactly how V8 multiplies BigInts: one digit at a time, adding up the intermediate results. The algorithm works just as well for <code>0</code> to <code>9</code> as it does for a BigInt’s much bigger digits.<p>Donald Knuth published a specific implementation of multiplication and division of large numbers made up of smaller chunks in Volume 2 of his classic <em>The Art of Computer Programming</em>, all the way back in 1969. V8’s implementation follows this book, which shows that this a pretty timeless piece of computer science.<h2 id=%E2%80%9Cless-desugaring%E2%80%9D-%3D%3D-more-sweets%3F>“Less desugaring” == more sweets? <a href=#%E2%80%9Cless-desugaring%E2%80%9D-%3D%3D-more-sweets%3F class=bookmark>#</a></h2><p>Perhaps surprisingly, we had to spend quite a bit of effort on getting seemingly simple unary operations, like <code>-x</code>, to work. So far, <code>-x</code> did exactly the same as <code>x * (-1)</code>, so to simplify things, V8 applied precisely this replacement as early as possible when processing JavaScript, namely in the parser. This approach is called “desugaring”, because it treats an expression like <code>-x</code> as “syntactic sugar” for <code>x * (-1)</code>. Other components (the interpreter, the compiler, the entire runtime system) didn’t even need to know what a unary operation is, because they only ever saw the multiplication, which of course they must support anyway.<p>With BigInts, however, this implementation suddenly becomes invalid, because multiplying a BigInt with a Number (like <code>-1</code>) must throw a <code>TypeError</code><sup class=footnote-ref><a href=#fn4 id=fnref4>[4]</a></sup>. The parser would have to desugar <code>-x</code> to <code>x * (-1n)</code> if <code>x</code> is a BigInt — but the parser has no way of knowing what <code>x</code> will evaluate to. So we had to stop relying on this early desugaring, and instead add proper support for unary operations on both Numbers and BigInts everywhere.<h2 id=a-bit-of-fun-with-bitwise-ops>A bit of fun with bitwise ops <a href=#a-bit-of-fun-with-bitwise-ops class=bookmark>#</a></h2><p>Most computer systems in use today store signed integers using a neat trick called “two’s complement”, which has the nice properties that the first bit indicates the sign, and adding 1 to the bit pattern always increments the number by 1, taking care of the sign bit automatically. For example, for 8-bit integers:<ul><li><code>10000000</code> is -128, the lowest representable number,<li><code>10000001</code> is -127,<li><code>11111111</code> is -1,<li><code>00000000</code> is 0,<li><code>00000001</code> is 1,<li><code>01111111</code> is 127, the highest representable number.</ul><p>This encoding is so common that many programmers expect it and rely on it, and the BigInt specification reflects this fact by prescribing that BigInts must act as if they used two’s complement representation. As described above, V8’s BigInts don’t!<p>To perform bitwise operations according to spec, our BigInts therefore must pretend to be using two’s complement under the hood. For positive values, it doesn’t make a difference, but negative numbers must do extra work to accomplish this. That has the somewhat surprising effect that <code>a & b</code>, if <code>a</code> and <code>b</code> are both negative BigInts, actually performs <em>four</em> steps (as opposed to just one if they were both positive): both inputs are converted to fake-two’s-complement format, then the actual operation is done, then the result is converted back to our real representation. Why the back-and-forth, you might ask? Because all the non-bitwise operations are much easier that way.<h2 id=two-new-types-of-typedarrays>Two new types of TypedArrays <a href=#two-new-types-of-typedarrays class=bookmark>#</a></h2><p>The BigInt proposal includes two new TypedArray flavors: <code>BigInt64Array</code> and <code>BigUint64Array</code>. We can have TypedArrays with 64-bit wide integer elements now that BigInts provide a natural way to read and write all the bits in those elements, whereas if one tried to use Numbers for that, some bits might get lost. That’s why the new arrays aren’t quite like the existing 8/16/32-bit integer TypedArrays: accessing their elements is always done with BigInts; trying to use Numbers throws an exception.<pre class=language-js><code class=language-js><span class="token operator">></span> <span class="token keyword">const</span> big_array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInt64Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token operator">></span> big_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">123n</span><span class="token punctuation">;</span>  <span class="token comment">// OK</span><br><span class="token operator">></span> big_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><br><span class="token number">123n</span><br><span class="token operator">></span> big_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><br><span class="token literal-property property">TypeError</span><span class="token operator">:</span> Cannot convert <span class="token number">456</span> to a BigInt<br><span class="token operator">></span> big_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK</span></code></pre><p>Just like JavaScript code working with these types of arrays looks and works a bit different from traditional TypedArray code, we had to generalize our TypedArray implementation to behave differently for the two newcomers.<h2 id=optimization-considerations>Optimization considerations <a href=#optimization-considerations class=bookmark>#</a></h2><p>For now, we are shipping a baseline implementation of BigInts. It is functionally complete and should provide solid performance (a little bit faster than existing userland libraries), but it is not particularly optimized. The reason is that, in line with our aim to prioritize real-world applications over artificial benchmarks, we first want to see how you will use BigInts, so that we can then optimize precisely the cases you care about!<p>For example, if we see that relatively small BigInts (up to 64 bits) are an important use case, we could make those more memory-efficient by using a special representation for them:<pre class=language-js><code class=language-js><span class="token punctuation">{</span><br>  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'BigInt-Int64'</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">0x12</span>…<span class="token punctuation">,</span><br><span class="token punctuation">}</span></code></pre><p>One of the details that remain to be seen is whether we should do this for “int64” value ranges, “uint64” ranges, or both — keeping in mind having to support fewer fast paths means that we can ship them sooner, and also that every additional fast path ironically makes everything else a bit slower, because affected operations always have to check whether it is applicable.<p>Another story is support for BigInts in the optimizing compiler. For computationally heavy applications operating on 64-bit values and running on 64-bit hardware, keeping those values in registers would be much more efficient than allocating them as objects on the heap as we currently do. We have plans for how we would implement such support, but it is another case where we would first like to find out whether that is really what you, our users, care about the most; or whether we should spend our time on something else instead.<p>Please send us feedback on what you’re using BigInts for, and any issues you encounter! You can reach us at our bug tracker <a href=https://crbug.com/v8/new>crbug.com/v8/new</a>, via mail to <a href=mailto:v8-users@googlegroups.com>v8-users@googlegroups.com</a>, or <a href=https://twitter.com/v8js>@v8js</a> on Twitter.<hr class=footnotes-sep><section class=footnotes><ol class=footnotes-list><li class=footnote-item id=fn1><p><em>Now</em> if you run Chrome Beta, Dev, or Canary, or a <a href=https://github.com/v8/node/tree/vee-eight-lkgr>preview Node.js version</a>, otherwise <em>soon</em> (Chrome 67, Node.js tip-of-tree probably around the same time). <a href=#fnref1 class=footnote-backref>↩︎</a><li class=footnote-item id=fn2><p>Arbitrary up to an implementation-defined limit. Sorry, we haven’t yet figured out how to squeeze an infinite amount of data into your computer’s finite amount of memory. <a href=#fnref2 class=footnote-backref>↩︎</a><li class=footnote-item id=fn3><p>On 64-bit machines, we use 64-bit digits, i.e. from 0 to 18446744073709551615 (i.e. <code>2n**64n-1n</code>). <a href=#fnref3 class=footnote-backref>↩︎</a><li class=footnote-item id=fn4><p>Mixing <code>BigInt</code> and <code>Number</code> operand types is generally not allowed. That’s somewhat unusual for JavaScript, but there is <a href=/features/bigint#operators>an explanation</a> for this decision. <a href=#fnref4 class=footnote-backref>↩︎</a></ol></section></div><footer><div><p>作者：Jakob Kummerow, arbitrator of precision.</div><a href=https://twitter.com/v8js/status/991705626391732224 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/bigint>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/bigint.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
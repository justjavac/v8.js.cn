<!doctype html><html lang=zh-CN><meta charset=utf-8><title>An additional non-backtracking RegExp engine Â· V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 now has an additional RegExp engine that serves as a fallback and prevents many instances of catastrophic backtracking." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>æ˜¾ç¤ºå¯¼è‚®</a><nav><ul><li><a href=/ >ä¸»é¡µ</a><li class=active><a href=/blog/ >åšå®¢</a><li><a href=/docs/ >æ–‡æ¡£</a><li><a href=/features title="JavaScript å’Œ WebAssembly çš„æ–°ç‰¹æ€§">JS/Wasm æ–°ç‰¹æ€§</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>An additional non-backtracking RegExp engine</h1><p class=meta>å‘å¸ƒæ—¶é—´ <time datetime="2021-01-11 00:00:00" itemprop=datePublished title="2021-01-11 00:00:00">2021-01-11</time> Â· æ ‡ç­¾ï¼š <a href=/blog/tags/internals/ class=tag>internals</a> <a href=/blog/tags/regexp/ class=tag>RegExp</a></header><div itemprop=articleBody><p>Starting with v8.8, V8 ships with a new experimental non-backtracking RegExp engine (in addition to the existing <a href=https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html>Irregexp engine</a>) which guarantees execution in linear time with respect to the size of the subject string. The experimental engine is available behind the feature flags mentioned below.<figure><img alt="" height=371 loading=lazy src=/_img/non-backtracking-regexp/runtime-plot.svg width=600><figcaption>Runtime of <code>/(a*)*b/.exec('a'.repeat(n))</code> for n â‰¤ 100</figcaption></figure><p>Hereâ€™s how you can configure the new RegExp engine:<ul><li><code>--enable-experimental-regexp_engine-on-excessive-backtracks</code> enables the fallback to the non-backtracking engine on excessive backtracks.<li><code>--regexp-backtracks-before-fallback N</code> (default N = 50,000) specifies how many backtracks are considered â€œexcessiveâ€, i.e. when the fallback kicks in.<li><code>--enable-experimental-regexp-engine</code> turns on recognition of the non-standard <code>l</code> (â€œlinearâ€) flag for RegExps, as in e.g. <code>/(a*)*b/l</code>. RegExps constructed with this flag are always eagerly executed with the new engine; Irregexp is not involved at all. If the new RegExp engine canâ€™t handle the pattern of an <code>l</code>-RegExp, then an exception is thrown at construction. We hope that this feature can at some point be used for hardening of apps that run RegExps on untrusted input. For now it remains experimental because Irregexp is orders of magnitude faster than the new engine on most common patterns.</ul><p>The fallback mechanism does not apply to all patterns. For the fallback mechanism to kick in, the RegExp must:<ul><li>not contain backreferences,<li>not contain lookaheads or lookbehinds,<li>not contain large or deeply nested finite repetitions, as in e.g. <code>/a{200,500}/</code>, and<li>not have the <code>u</code> (Unicode) or <code>i</code> (case insensitive) flags set.</ul><h2 id=background%3A-catastrophic-backtracking>Background: catastrophic backtracking <a href=#background%3A-catastrophic-backtracking class=bookmark>#</a></h2><p>RegExp matching in V8 is handled by the Irregexp engine. Irregexp jit-compiles RegExps to specialized native code (or <a href=blog/regexp-tier-up>bytecode</a>) and is thus extremely fast for most patterns. For some patterns, however, Irregexpâ€™s runtime can blow up exponentially in the size of the input string. The example above, <code>/(a*)*b/.exec('a'.repeat(100))</code>, does not finish within our lifetimes if executed by Irregexp.<p>So whatâ€™s going on here? Irregexp is a <em>backtracking</em> engine. When faced with a choice of how a match can continue, Irregexp explores the first alternative in its entirety, and then backtracks if necessary to explore the second alternative. Consider for instance matching the pattern <code>/abc|[az][by][0-9]/</code> against the subject string <code>'ab3'</code>. Here Irregexp tries to match <code>/abc/</code> first and fails after the second character. It then backtracks by two characters and successfully matches the second alternative <code>/[az][by][0-9]/</code>. In patterns with quantifiers such as <code>/(abc)*xyz/</code>, Irregexp has to choose after a match of the body whether to match the body again or to continue with the remaining pattern.<p>Letâ€™s try to understand whatâ€™s going on when matching <code>/(a*)*b/</code> against a smaller subject string, say <code>'aaa'</code>. This pattern contains nested quantifiers, so weâ€™re asking Irregexp to match a <em>sequence of sequences</em> of <code>'a'</code>, and then match <code>'b'</code>. Clearly there is no match because the subject string does not contain <code>'b'</code>. However, <code>/(a*)*/</code> matches, and it does so in exponentially many different ways:<pre class=language-js><code class=language-js><span class="token string">'aaa'</span>           <span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token string">'a'</span>           <span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token string">''</span><br><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'aa'</span>       <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span>       <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">''</span><br>â€¦</code></pre><p>A priori, Irregexp cannot rule out that the failure to match the final <code>/b/</code> is due to choosing the wrong way of matching <code>/(a*)*/</code>, so it has to try all variants. This problem is known as â€œexponentialâ€ or â€œcatastrophicâ€ backtracking.<h2 id=regexps-as-automata-and-bytecode>RegExps as automata and bytecode <a href=#regexps-as-automata-and-bytecode class=bookmark>#</a></h2><p>To understand an alternative algorithm that is immune to catastrophic backtracking, we have to take a quick detour via <a href=https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton>automata</a>. Every regular expression is equivalent to an automaton. For example, the RegExp <code>/(a*)*b/</code> above corresponds to the following automaton:<figure><img alt="" height=509 loading=lazy src=/_img/non-backtracking-regexp/example-automaton.svg width=1067><figcaption>Automaton corresponding to <code>/(a*)*b/</code></figcaption></figure><p>Note that the automaton is not uniquely determined by the pattern; the one you see above is the automaton you will get by a mechanical translation process, and itâ€™s the one thatâ€™s used inside the V8â€™s new RegExp engine for <code>/(a*)*/</code>.<br>The unlabeled edges are epsilon transitions: They donâ€™t consume input. Epsilon transitions are necessary to keep the size of the automaton at around the size of the pattern. Naively eliminating epsilon transitions can result in quadratic increase of the number of transitions.<br>Epsilon transitions also allow constructing the automaton corresponding to a RegExp from the following four basic kinds of states:<figure><img alt="" height=260 loading=lazy src=/_img/non-backtracking-regexp/state-types.svg width=360><figcaption>RegExp bytecode instructions</figcaption></figure><p>Here we only classify the transitions <em>out</em> of the state, while the transitions into the state are still allowed to be arbitrary. Automata built from only these kinds of states can be represented as <em>bytecode programs</em>, with every state corresponding to an instruction. For example, a state with two epsilon transitions is represented as a <code>FORK</code> instruction.<h2 id=the-backtracking-algorithm>The backtracking algorithm <a href=#the-backtracking-algorithm class=bookmark>#</a></h2><p>Letâ€™s revisit the backtracking algorithm that Irregexp is based upon and describe it in terms of automata. Suppose weâ€™re given a bytecode array <code>code</code> corresponding to the pattern and want to <code>test</code> whether an <code>input</code> matches the pattern. Letâ€™s assume that <code>code</code> looks something like this:<pre class=language-js><code class=language-js><span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'FORK'</span><span class="token punctuation">,</span> forkPc<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'CONSUME'</span><span class="token punctuation">,</span> char<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'CONSUME'</span><span class="token punctuation">,</span> char<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'JMP'</span><span class="token punctuation">,</span> jmpPc<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'CONSUME'</span><span class="token punctuation">,</span> char<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'CONSUME'</span><span class="token punctuation">,</span> char<span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span>opcode<span class="token operator">:</span> <span class="token string">'ACCEPT'</span><span class="token punctuation">}</span><br><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>This bytecode corresponds to the (sticky) pattern <code>/12|ab/y</code>. The <code>forkPc</code> field of the <code>FORK</code> instruction is the index (â€œprogram counterâ€) of the alternative state/instruction that we can continue at, and similarly for <code>jmpPc</code>. Indices are zero-based. The backtracking algorithm can now be implemented in JavaScript as follows.<pre class=language-js><code class=language-js><span class="token keyword">let</span> ip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Input position.</span><br><span class="token keyword">let</span> pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Program counter: index of the next instruction.</span><br><span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Backtrack stack.</span><br><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> inst <span class="token operator">=</span> code<span class="token punctuation">[</span>pc<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>inst<span class="token punctuation">.</span>opcode<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> <span class="token string">'CONSUME'</span><span class="token operator">:</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ip <span class="token operator">&lt;</span> input<span class="token punctuation">.</span>length <span class="token operator">&&</span> input<span class="token punctuation">[</span>ip<span class="token punctuation">]</span> <span class="token operator">===</span> inst<span class="token punctuation">.</span>char<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Input matches what we expect: Continue.</span><br>        <span class="token operator">++</span>ip<span class="token punctuation">;</span><br>        <span class="token operator">++</span>pc<span class="token punctuation">;</span><br>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Wrong input character, but we can backtrack.</span><br>        <span class="token keyword">const</span> back <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        ip <span class="token operator">=</span> back<span class="token punctuation">.</span>ip<span class="token punctuation">;</span><br>        pc <span class="token operator">=</span> back<span class="token punctuation">.</span>pc<span class="token punctuation">;</span><br>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token comment">// Wrong character, cannot backtrack.</span><br>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'FORK'</span><span class="token operator">:</span><br>      <span class="token comment">// Save alternative for backtracking later.</span><br>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ip<span class="token operator">:</span> ip<span class="token punctuation">,</span> pc<span class="token operator">:</span> inst<span class="token punctuation">.</span>forkPc<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token operator">++</span>pc<span class="token punctuation">;</span><br>      <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'JMP'</span><span class="token operator">:</span><br>      pc <span class="token operator">=</span> inst<span class="token punctuation">.</span>jmpPc<span class="token punctuation">;</span><br>      <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token keyword">case</span> <span class="token string">'ACCEPT'</span><span class="token operator">:</span><br>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>This implementation loops indefinitely if the bytecode program contains loops that do not consume any character, i.e. if the automaton contains a loop consisting of epsilon transitions only. This issue can be solved with lookahead by a single character. Irregexp is much more sophisticated than this simple implementation, but ultimately based on the same algorithm.<h2 id=the-non-backtracking-algorithm>The non-backtracking algorithm <a href=#the-non-backtracking-algorithm class=bookmark>#</a></h2><p>The backtracking algorithm corresponds to <em>depth-first</em> traversal of the automaton: We always explore the first alternative of a <code>FORK</code> statement in its entirety and then backtrack to the second alternative if necessary. The alternative to it, the non-backtracking algorithm, is thus unsurprisingly based on <em>breadth-first</em> traversal of the automaton. Here we consider all alternatives simultaneously, in lockstep with respect to the current position in the input string. We thus maintain a list of current states, and then advance all states by taking transitions corresponding to each input character. Crucially, we remove duplicates from the list of current states.<p>A simple implementation in JavaScript looks something like this:<pre class=language-js><code class=language-js><span class="token comment">// Input position.</span><br><span class="token keyword">let</span> ip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// List of current pc values, or `'ACCEPT'` if weâ€™ve found a match. We start at</span><br><span class="token comment">// pc 0 and follow epsilon transitions.</span><br><span class="token keyword">let</span> pcs <span class="token operator">=</span> <span class="token function">followEpsilons</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Weâ€™re done if weâ€™ve found a matchâ€¦</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pcs <span class="token operator">===</span> <span class="token string">'ACCEPT'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>  <span class="token comment">// â€¦or if weâ€™ve exhausted the input string.</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ip <span class="token operator">>=</span> input<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Continue only with the pcs that CONSUME the correct character.</span><br>  pcs <span class="token operator">=</span> pcs<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">pc</span> <span class="token operator">=></span> code<span class="token punctuation">[</span>pc<span class="token punctuation">]</span><span class="token punctuation">.</span>char <span class="token operator">===</span> input<span class="token punctuation">[</span>ip<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Advance the remaining pcs to the next instruction.</span><br>  pcs <span class="token operator">=</span> pcs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">pc</span> <span class="token operator">=></span> pc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Follow epsilon transitions.</span><br>  pcs <span class="token operator">=</span> <span class="token function">followEpsilons</span><span class="token punctuation">(</span>pcs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token operator">++</span>ip<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here <code>followEpsilons</code> is a function that takes a list of program counters and computes the list of program counters at <code>CONSUME</code> instructions that can be reached via epsilon transitions (i.e. by only executing FORK and JMP). The returned list must not contain duplicates. If an <code>ACCEPT</code> instruction can be reached, the function returns <code>'ACCEPT'</code>. It can be implemented like this:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">followEpsilons</span><span class="token punctuation">(</span><span class="token parameter">pcs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Set of pcs weâ€™ve seen so far.</span><br>  <span class="token keyword">const</span> visitedPcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">while</span> <span class="token punctuation">(</span>pcs<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> pc <span class="token operator">=</span> pcs<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token comment">// We can ignore pc if weâ€™ve seen it earlier.</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>visitedPcs<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><br>    visitedPcs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">const</span> inst <span class="token operator">=</span> code<span class="token punctuation">[</span>pc<span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>inst<span class="token punctuation">.</span>opcode<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">case</span> <span class="token string">'CONSUME'</span><span class="token operator">:</span><br>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">break</span><span class="token punctuation">;</span><br>      <span class="token keyword">case</span> <span class="token string">'FORK'</span><span class="token operator">:</span><br>        pcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inst<span class="token punctuation">.</span>forkPc<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">break</span><span class="token punctuation">;</span><br>      <span class="token keyword">case</span> <span class="token string">'JMP'</span><span class="token operator">:</span><br>        pcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>inst<span class="token punctuation">.</span>jmpPc<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">break</span><span class="token punctuation">;</span><br>      <span class="token keyword">case</span> <span class="token string">'ACCEPT'</span><span class="token operator">:</span><br>        <span class="token keyword">return</span> <span class="token string">'ACCEPT'</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Because of the elimination of duplicates via the <code>visitedPcs</code> set, we know that every program counter is only examined once in <code>followEpsilons</code>. This guarantees that the <code>result</code> list does not contain duplicates, and that the runtime of <code>followEpsilons</code> is bounded by the size of the <code>code</code> array, i.e. the size of the pattern. <code>followEpsilons</code> is called at most <code>input.length</code> times, so the total runtime of RegExp matching is bounded by <code>ğ’ª(pattern.length * input.length)</code>.<p>The non-backtracking algorithm can be extended to support most features of JavaScript RegExps, for example word boundaries or the calculation of (sub)match boundaries. Unfortunately, backreferences, lookahead and lookbehind cannot be supported without major changes that alter asymptotic worst-case complexity.<p>V8â€™s new RegExp engine is based on this algorithm and its implementation in the <a href=https://github.com/google/re2>re2</a> and <a href=https://github.com/rust-lang/regex>Rust regex</a> libraries. The algorithm is discussed in much more depth than here in an excellent <a href=https://swtch.com/~rsc/regexp/ >series of blog posts</a> by Russ Cox, who is also the original author of the re2 library.</div><footer><div><p>ä½œè€…ï¼šMartin Bidlingmaier.</div><a href=https://twitter.com/v8js/status/1348635270762139650 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/non-backtracking-regexp>åŸæ–‡</a> Â· <a href=/logo/ >å•†æ ‡</a> Â· <a href=/terms/ >æ¡æ¬¾</a> Â· <a href=https://policies.google.com/privacy/ >éšç§</a> Â· <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> Â· <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/non-backtracking-regexp.md rel=nofollow>åœ¨ GitHub ç¼–è¾‘æ­¤é¡µé¢</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>å¦‚æ— ç‰¹æ®Šè¯´æ˜ï¼Œæ­¤ V8 é¡¹ç›®ä¸­ä½¿ç”¨åˆ°çš„æ‰€æœ‰ç¤ºä¾‹ä»£ç å‡åŸºäº <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> å‘å¸ƒã€‚é¡µé¢ä¸­çš„æ–‡å­—å†…å®¹é‡‡ç”¨ <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> è¿›è¡Œè®¸å¯ã€‚æ›´è¯¦ç»†çš„ä¿¡æ¯å¯ä»¥åœ¨ <a href=/terms#site-policies>ç«™ç‚¹ç­–ç•¥</a> ä¸­æ‰¾åˆ°ã€‚</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
<!doctype html><html lang=zh-CN><meta charset=utf-8><title>V8 release v6.8 · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="V8 v6.8 features reduced memory consumption and several performance improvements." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>V8 release v6.8</h1><p class=meta>发布时间 <time datetime="2018-06-21 13:33:37" itemprop=datePublished title="2018-06-21 13:33:37">2018-06-21</time> · 标签： <a href=/blog/tags/release/ class=tag>release</a></header><div itemprop=articleBody><p>Every six weeks, we create a new branch of V8 as part of our <a href=/docs/release-process>release process</a>. Each version is branched from V8’s Git master immediately before a Chrome Beta milestone. Today we’re pleased to announce our newest branch, <a href=https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/6.8>V8 version 6.8</a>, which is in beta until its release in coordination with Chrome 68 Stable in several weeks. V8 v6.8 is filled with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release.<h2 id=memory>Memory <a href=#memory class=bookmark>#</a></h2><p>JavaScript functions unnecessarily kept outer functions and their metadata (known as <code>SharedFunctionInfo</code> or <code>SFI</code>) alive. Especially in function-heavy code that relies on short-lived IIFEs, this could lead to spurious memory leaks. Before this change, an active <code>Context</code> (i.e. an on-heap representation of a function activation) kept the <code>SFI</code> alive of the function that created the context:<figure><img alt="" height=210 loading=lazy src=/_img/v8-release-68/context-jsfunction-before.svg width=714></figure><p>By letting the <code>Context</code> point to a <code>ScopeInfo</code> object which contains the stripped-down information necessary for debugging, we can break the dependency on the <code>SFI</code>.<figure><img alt="" height=187 loading=lazy src=/_img/v8-release-68/context-jsfunction-after.svg width=714></figure><p>We’ve already observed 3% V8 memory improvements on mobile devices over a set of top 10 pages.<p>In parallel we have reduced the memory consumption of <code>SFI</code>s themselves, removing unnecessary fields or compressing them where possible, and decreased their size by ~25%, with further reductions coming in future releases. We’ve observed <code>SFI</code>s taking up 2–6% of V8 memory on typical websites even after detaching them from the context, so you should see memory improvements on code with a large number of functions.<h2 id=performance>Performance <a href=#performance class=bookmark>#</a></h2><h3 id=array-destructuring-improvements>Array destructuring improvements <a href=#array-destructuring-improvements class=bookmark>#</a></h3><p>The optimizing compiler did not generate ideal code for array destructuring. For example, swapping variables using <code>[a, b] = [b, a]</code> used to be twice as slow as <code>const tmp = a; a = b; b = tmp</code>. Once we unblocked escape analysis to eliminate all temporary allocation, array destructuring with a temporary array is as fast as a sequence of assignments.<h3 id=object.assign-improvements><code>Object.assign</code> improvements <a href=#object.assign-improvements class=bookmark>#</a></h3><p>So far <code>Object.assign</code> had a fast path written in C++. That meant that the JavaScript-to-C++ boundary had to be crossed for each <code>Object.assign</code> call. An obvious way to improve the builtin performance was to implement a fast path on the JavaScript side. We had two options: either implement it as an native JS builtin (which would come with some unnecessary overhead in this case), or implement it <a href=/blog/csa>using CodeStubAssembler technology</a> (which provides more flexibility). We went with the latter solution. The new implementation of <code>Object.assign</code> improves the score of <a href="https://chromeperf.appspot.com/report?sid=d9ea9a2ae7cd141263fde07ea90da835cf28f5c87f17b53ba801d4ac30979558&start_rev=550155&end_rev=552590">Speedometer2/React-Redux by about 15%, improving the total Speedometer 2 score by 1.5%</a>.<h3 id=typedarray.prototype.sort-improvements><code>TypedArray.prototype.sort</code> improvements <a href=#typedarray.prototype.sort-improvements class=bookmark>#</a></h3><p><code>TypedArray.prototype.sort</code> has two paths: a fast path, used when the user does not provide a comparison function, and a slow path for everything else. Until now, the slow path reused the implementation for <code>Array.prototype.sort</code>, which does a lot more than is necessary for sorting <code>TypedArray</code>s. V8 v6.8 replaces the slow path with an implementation in <a href=/blog/csa>CodeStubAssembler</a>. (Not directly CodeStubAssembler but a domain-specific language that is built on top of CodeStubAssembler).<p>Performance for sorting <code>TypedArray</code>s without a comparison function stays the same while there is a speedup of up to 2.5× when sorting using a comparison function.<figure><img alt="" height=371 loading=lazy src=/_img/v8-release-68/typedarray-sort.svg width=600></figure><h2 id=webassembly>WebAssembly <a href=#webassembly class=bookmark>#</a></h2><p>In V8 v6.8 you can start using <a href=https://docs.google.com/document/d/17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M/edit>trap-based bounds checking</a> on Linux x64 platforms. This memory management optimization considerably improves WebAssembly’s execution speed. It’s already used in Chrome 68, and in the future more platforms will be supported incrementally.<h2 id=v8-api>V8 API <a href=#v8-api class=bookmark>#</a></h2><p>Please use <code>git log branch-heads/6.7..branch-heads/6.8 include/v8.h</code> to get a list of the API changes.<p>Developers with an <a href=/docs/source-code#using-git>active V8 checkout</a> can use <code>git checkout -b 6.8 -t branch-heads/6.8</code> to experiment with the new features in V8 v6.8. Alternatively you can <a href=https://www.google.com/chrome/browser/beta.html>subscribe to Chrome’s Beta channel</a> and try the new features out yourself soon.</div><footer><div><p>作者：the V8 team.</div><a href=https://twitter.com/v8js/status/1009753739060826112 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/v8-release-68>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/v8-release-68.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
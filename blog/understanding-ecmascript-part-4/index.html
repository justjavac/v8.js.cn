<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Understanding the ECMAScript spec, part 4 · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="Tutorial on reading the ECMAScript specification" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Understanding the ECMAScript spec, part 4</h1><p class=meta>发布时间 <time datetime="2020-05-19 00:00:00" itemprop=datePublished title="2020-05-19 00:00:00">2020-05-19</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/understanding-ecmascript/ class=tag>Understanding ECMAScript</a></header><div itemprop=articleBody><p><a href=/blog/tags/understanding-ecmascript>All episodes</a><h2 id=meanwhile-in-other-parts-of-the-web>Meanwhile in other parts of the Web <a href=#meanwhile-in-other-parts-of-the-web class=bookmark>#</a></h2><p><a href=https://github.com/jorendorff>Jason Orendorff</a> from Mozilla published <a href=https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#readme>a great in-depth analysis of JS syntactic quirks</a>. Even though the implementation details differ, every JS engine faces the same problems with these quirks.<h2 id=cover-grammars>Cover grammars <a href=#cover-grammars class=bookmark>#</a></h2><p>In this episode, we take a deeper look into <em>cover grammars</em>. They are a way to specify the grammar for syntactic constructs which look ambiguous at first.<p>Again, we'll skip the subscripts for <code>[In, Yield, Await]</code> for brevity, as they aren't important for this blog post. See <a href=/blog/understanding-ecmascript-part-3>part 3</a> for an explanation of their meaning and usage.<h2 id=finite-lookaheads>Finite lookaheads <a href=#finite-lookaheads class=bookmark>#</a></h2><p>Typically, parsers decide which production to use based on a finite lookahead (a fixed amount of following tokens).<p>In some cases, the next token determines the production to use unambiguously. <a href=https://tc39.es/ecma262/#prod-UpdateExpression>For example</a>:<pre class=language-grammar><code class=language-grammar><span class="token production-name">UpdateExpression</span> <span class="token literal">:</span><br>  <span class="token production-name">LeftHandSideExpression</span><br>  <span class="token production-name">LeftHandSideExpression</span> <span class="token literal">++</span><br>  <span class="token production-name">LeftHandSideExpression</span> <span class="token literal">--</span><br>  <span class="token literal">++</span> <span class="token production-name">UnaryExpression</span><br>  <span class="token literal">--</span> <span class="token production-name">UnaryExpression</span></code></pre><p>If we're parsing an <code>UpdateExpression</code> and the next token is <code>++</code> or <code>--</code>, we know the production to use right away. If the next token is neither, it's still not too bad: we can parse a <code>LeftHandSideExpression</code> starting from the position we're at, and figure out what to do after we've parsed it.<p>If the token following the <code>LeftHandSideExpression</code> is <code>++</code>, the production to use is <code>UpdateExpression : LeftHandSideExpression ++</code>. The case for <code>--</code> is similar. And if the token following the <code>LeftHandSideExpression</code> is neither <code>++</code> nor <code>--</code>, we use the production <code>UpdateExpression : LeftHandSideExpression</code>.<h3 id=arrow-function-parameter-list-or-a-parenthesized-expression%3F>Arrow function parameter list or a parenthesized expression? <a href=#arrow-function-parameter-list-or-a-parenthesized-expression%3F class=bookmark>#</a></h3><p>Distinguishing arrow function parameter lists from parenthesized expressions is more complicated.<p>For example:<pre class=language-js><code class=language-js><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span></code></pre><p>Is this the start of an arrow function, like this?<pre class=language-js><code class=language-js><span class="token keyword">let</span> <span class="token function function-variable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Or maybe it's a parenthesized expression, like this?<pre class=language-js><code class=language-js><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The parenthesized whatever-it-is can be arbitrarily long - we cannot know what it is based on a finite amount of tokens.<p>Let's imagine for a moment that we had the following straightforward productions:<pre class=language-grammar><code class=language-grammar><span class="token production-name">AssignmentExpression</span> <span class="token literal">:</span><br>  <span class="token literal">...</span><br>  <span class="token production-name">ArrowFunction</span><br>  <span class="token production-name">ParenthesizedExpression</span><br><br><span class="token production-name">ArrowFunction</span> <span class="token literal">:</span><br>  <span class="token production-name">ArrowParameterList</span> <span class="token literal">=></span> <span class="token production-name">ConciseBody</span></code></pre><p>Now we can't choose the production to use with a finite lookahead. If we had to parse a <code>AssignmentExpression</code> and the next token was <code>(</code>, how would we decide what to parse next? We could either parse an <code>ArrowParameterList</code> or a <code>ParenthesizedExpression</code>, but our guess could go wrong.<h3 id=the-very-permissive-new-symbol%3A-cpeaapl>The very permissive new symbol: <code>CPEAAPL</code> <a href=#the-very-permissive-new-symbol%3A-cpeaapl class=bookmark>#</a></h3><p>The spec solves this problem by introducing the symbol <code>CoverParenthesizedExpressionAndArrowParameterList</code> (<code>CPEAAPL</code> for short). <code>CPEAAPL</code> is a symbol that is actually an <code>ParenthesizedExpression</code> or an <code>ArrowParameterList</code> behind the scenes, but we don't yet know which one.<p>The <a href=https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList>productions</a> for <code>CPEAAPL</code> are very permissive, allowing all constructs that can occur in <code>ParenthesizedExpression</code>s and in <code>ArrowParameterList</code>s:<pre class=language-grammar><code class=language-grammar><span class="token production-name">CPEAAPL</span> <span class="token literal">:</span><br>  <span class="token literal">(</span> <span class="token production-name">Expression</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token production-name">Expression</span> <span class="token literal">,</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token literal">...</span> <span class="token production-name">BindingIdentifier</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token literal">...</span> <span class="token production-name">BindingPattern</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token production-name">Expression</span> <span class="token literal">,</span> <span class="token literal">...</span> <span class="token production-name">BindingIdentifier</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token production-name">Expression</span> <span class="token literal">,</span> <span class="token literal">...</span> <span class="token production-name">BindingPattern</span> <span class="token literal">)</span></code></pre><p>For example, the following expressions are valid <code>CPEAAPL</code>s:<pre class=language-js><code class=language-js><span class="token comment">// Valid ParenthesizedExpression and ArrowParameterList:</span><br><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><br><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><br><br><span class="token comment">// Valid ParenthesizedExpression:</span><br><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><br><br><span class="token comment">// Valid ArrowParameterList:</span><br><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">)</span><br><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">)</span><br><br><span class="token comment">// Not valid either, but still a CPEAAPL:</span><br><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">)</span></code></pre><p>Trailing comma and the <code>...</code> can occur only in <code>ArrowParameterList</code>. Some constructs, like <code>b = 1</code> can occur in both, but they have different meanings: Inside <code>ParenthesizedExpression</code> it's an assignment, inside <code>ArrowParameterList</code> it's a parameter with a default value. Numbers and other <code>PrimaryExpressions</code> which are not valid parameter names (or parameter destructuring patterns) can only occur in <code>ParenthesizedExpression</code>. But they all can occur inside a <code>CPEAAPL</code>.<h3 id=using-cpeaapl-in-productions>Using <code>CPEAAPL</code> in productions <a href=#using-cpeaapl-in-productions class=bookmark>#</a></h3><p>Now we can use the very permissive <code>CPEAAPL</code> in <a href=https://tc39.es/ecma262/#prod-AssignmentExpression><code>AssignmentExpression</code> productions</a>. (Note: <code>ConditionalExpression</code> leads to <code>PrimaryExpression</code> via a long production chain which is not shown here.)<pre class=language-grammar><code class=language-grammar><span class="token production-name">AssignmentExpression</span> <span class="token literal">:</span><br>  <span class="token production-name">ConditionalExpression</span><br>  <span class="token production-name">ArrowFunction</span><br>  <span class="token literal">...</span><br><br><span class="token production-name">ArrowFunction</span> <span class="token literal">:</span><br>  <span class="token production-name">ArrowParameters</span> <span class="token literal">=></span> <span class="token production-name">ConciseBody</span><br><br><span class="token production-name">ArrowParameters</span> <span class="token literal">:</span><br>  <span class="token production-name">BindingIdentifier</span><br>  <span class="token production-name">CPEAAPL</span><br><br><span class="token production-name">PrimaryExpression</span> <span class="token literal">:</span><br>  <span class="token literal">...</span><br>  <span class="token production-name">CPEAAPL</span><br></code></pre><p>Imagine we're again in the situation that we need to parse an <code>AssignmentExpression</code> and the next token is <code>(</code>. Now we can parse a <code>CPEAAPL</code> and figure out later what production to use. It doesn't matter whether we're parsing an <code>ArrowFunction</code> or a <code>ConditionalExpression</code>, the next symbol to parse is <code>CPEAAPL</code> in any case!<p>After we've parsed the <code>CPEAAPL</code>, we can decide which production to use for the original <code>AssignmentExpression</code> (the one containing the <code>CPEAAPL</code>). This decision is made based on the token following the <code>CPEAAPL</code>.<p>If the token is <code>=></code>, we use the production:<pre class=language-grammar><code class=language-grammar><span class="token production-name">AssignmentExpression</span> <span class="token literal">:</span><br>  <span class="token production-name">ArrowFunction</span></code></pre><p>If the token is something else, we use the production:<pre class=language-grammar><code class=language-grammar><span class="token production-name">AssignmentExpression</span> <span class="token literal">:</span><br>  <span class="token production-name">ConditionalExpression</span></code></pre><p>For example:<pre class=language-js><code class=language-js><span class="token keyword">let</span> <span class="token function function-variable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token comment">//      ^^^^^^</span><br><span class="token comment">//     CPEAAPL</span><br><span class="token comment">//             ^^</span><br><span class="token comment">//             The token following the CPEAAPL</span><br><br><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">//      ^^^^^^</span><br><span class="token comment">//     CPEAAPL</span><br><span class="token comment">//            ^</span><br><span class="token comment">//            The token following the CPEAAPL</span></code></pre><p>At that point we can keep the <code>CPEAAPL</code> as is and continue parsing the rest of the program. For example, if the <code>CPEAAPL</code> is inside an <code>ArrowFunction</code>, we don't yet need to look at whether it's a valid arrow function parameter list or not - that can be done later. (Real-world parsers might choose to do the validity check right away, but from the spec point of view, we don't need to.)<h3 id=restricting-cpeaapls>Restricting CPEAAPLs <a href=#restricting-cpeaapls class=bookmark>#</a></h3><p>As we saw before, the grammar productions for <code>CPEAAPL</code> are very permissive and allow constructs (such as <code>(1, ...a)</code>) which are never valid. After we've done parsing the program according to the grammar, we need to disallow the corresponding illegal constructs.<p>The spec does this by adding the following restrictions:<div class=ecmascript-algorithm><blockquote><p><a href=https://tc39.es/ecma262/#sec-grouping-operator-static-semantics-early-errors>Static Semantics: Early Errors</a><p><code>PrimaryExpression : CPEAAPL</code><p>It is a Syntax Error if <code>CPEAAPL</code> is not covering a <code>ParenthesizedExpression</code>.</blockquote><div class=ecmascript-algorithm><blockquote><p><a href=https://tc39.es/ecma262/#sec-primary-expression>Supplemental Syntax</a><p>When processing an instance of the production<p><code>PrimaryExpression : CPEAAPL</code><p>the interpretation of the <code>CPEAAPL</code> is refined using the following grammar:<p><code>ParenthesizedExpression : ( Expression )</code></blockquote><p>This means: if a <code>CPEAAPL</code> occurs in the place of <code>PrimaryExpression</code> in the syntax tree, it is actually an <code>ParenthesizedExpression</code> and this is its only valid production.<p><code>Expression</code> can never be empty, so <code>( )</code> is not a valid <code>ParenthesizedExpression</code>. Comma separated lists like <code>(1, 2, 3)</code> are created by <a href=https://tc39.es/ecma262/#sec-comma-operator>the comma operator</a>:<pre class=language-grammar><code class=language-grammar><span class="token production-name">Expression</span> <span class="token literal">:</span><br>  <span class="token production-name">AssignmentExpression</span><br>  <span class="token production-name">Expression</span> <span class="token literal">,</span> <span class="token production-name">AssignmentExpression</span></code></pre><p>Similarly, if a <code>CPEAAPL</code> occurs in the place of <code>ArrowParameters</code>, the following restrictions apply:<div class=ecmascript-algorithm><blockquote><p><a href=https://tc39.es/ecma262/#sec-arrow-function-definitions-static-semantics-early-errors>Static Semantics: Early Errors</a><p><code>ArrowParameters : CPEAAPL</code><p>It is a Syntax Error if <code>CPEAAPL</code> is not covering an <code>ArrowFormalParameters</code>.</blockquote><div class=ecmascript-algorithm><blockquote><p><a href=https://tc39.es/ecma262/#sec-arrow-function-definitions>Supplemental Syntax</a><p>When the production<p><code>ArrowParameters</code> : <code>CPEAAPL</code><p>is recognized the following grammar is used to refine the interpretation of <code>CPEAAPL</code>:<p><code>ArrowFormalParameters :</code><br><code>( UniqueFormalParameters )</code></blockquote><h3 id=other-cover-grammars>Other cover grammars <a href=#other-cover-grammars class=bookmark>#</a></h3><p>In addition to <code>CPEAAPL</code>, the spec uses cover grammars for other ambiguous-looking constructs.<p><code>ObjectLiteral</code> is used as a cover grammar for <code>ObjectAssignmentPattern</code> which occurs inside arrow function parameter lists. This means that <code>ObjectLiteral</code> allows constructs which cannot occur inside actual object literals.<pre class=language-grammar><code class=language-grammar><span class="token production-name">ObjectLiteral</span> <span class="token literal">:</span><br>  <span class="token literal">...</span><br>  <span class="token literal">{</span> <span class="token production-name">PropertyDefinitionList</span> <span class="token literal">}</span><br><br><span class="token production-name">PropertyDefinition</span> <span class="token literal">:</span><br>  <span class="token literal">...</span><br>  <span class="token production-name">CoverInitializedName</span><br><br><span class="token production-name">CoverInitializedName</span> <span class="token literal">:</span><br>  <span class="token production-name">IdentifierReference</span> <span class="token production-name">Initializer</span><br><br><span class="token production-name">Initializer</span> <span class="token literal">:</span><br>  <span class="token literal">=</span> <span class="token production-name">AssignmentExpression</span></code></pre><p>For example:<pre class=language-js><code class=language-js><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// syntax error</span><br><br><span class="token comment">// Arrow function with a destructuring parameter with a default</span><br><span class="token comment">// value:</span><br><span class="token keyword">let</span> <span class="token function function-variable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 1</span><br><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">a</span> <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 6</span></code></pre><p>Async arrow functions also look ambiguous with a finite lookahead:<pre class=language-js><code class=language-js><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span></code></pre><p>Is this a call to a function called <code>async</code> or an async arrow function?<pre class=language-js><code class=language-js><span class="token keyword">let</span> x1 <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> x2 <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><br><br><span class="token keyword">let</span> <span class="token function function-variable">x3</span> <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> x4 <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To this end, the grammar defines a cover grammar symbol <code>CoverCallExpressionAndAsyncArrowHead</code> which works similarly to <code>CPEAAPL</code>.<h2 id=summary>Summary <a href=#summary class=bookmark>#</a></h2><p>In this episode we looked into how the spec defines cover grammars and uses them in cases where we cannot identify the current syntactic construct based on a finite lookahead.<p>In particular, we looked into distinguishing arrow function parameter lists from parenthesized expressions and how the spec uses a cover grammar for first parsing ambiguous-looking constructs permissively and restricting them with static semantic rules later.</div></div></div></div></div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/marja-holtta.jpg srcset="/_img/avatars/marja-holtta@2x.jpg 2x" width=96></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, speculative specification spectator.</div><a href=https://twitter.com/v8js/status/1262815621756014594 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/understanding-ecmascript-part-4>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/understanding-ecmascript-part-4.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
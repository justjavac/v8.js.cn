<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Optimizing ES2015 proxies in V8 · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="This article explains how V8 improved JavaScript proxies performance." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Optimizing ES2015 proxies in V8</h1><p class=meta>发布时间 <time datetime="2017-10-05 13:33:37" itemprop=datePublished title="2017-10-05 13:33:37">2017-10-05</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/benchmarks/ class=tag>benchmarks</a> <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>Proxies have been an integral part of JavaScript since ES2015. They allow intercepting fundamental operations on objects and customizing their behavior. Proxies form a core part of projects like <a href=https://github.com/tmpvar/jsdom>jsdom</a> and the <a href=https://github.com/GoogleChrome/comlink>Comlink RPC library</a>. Recently, we put a lot of effort into improving the performance of proxies in V8. This article sheds some light on general performance improvement patterns in V8 and for proxies in particular.<p>Proxies are “objects used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc.)” (definition by <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy>MDN</a>). More info can be found in the <a href=https://tc39.es/ecma262/#sec-proxy-objects>full specification</a>. For example, the following code snippet adds logging to every property access on the object:<pre class=language-js><code class=language-js><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> callTracer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span><br>  <span class="token function function-variable">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">get was called for: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span>name<span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> target<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>callTracer<span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>callTracer<span class="token punctuation">.</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// get was called for: property</span><br><span class="token comment">// value</span></code></pre><h2 id=constructing-proxies>Constructing proxies <a href=#constructing-proxies class=bookmark>#</a></h2><p>The first feature we'll focus on is the <strong>construction</strong> of proxies. Our original C++ implementation here followed the ECMAScript specification step-by-step, resulting in at least 4 jumps between the C++ and JS runtimes as shown in the following figure. We wanted to port this implementation into the platform-agnostic <a href=/docs/csa-builtins>CodeStubAssembler</a> (CSA), which is executed in the JS runtime as opposed to the C++ runtime.This porting minimizes that number of jumps between the language runtimes. <code>CEntryStub</code> and <code>JSEntryStub</code> represent the runtimes in the figure below. The dotted lines represent the borders between the JS and C++ runtimes. Luckily, lots of <a href=https://github.com/v8/v8/blob/4e5db9a6c859df7af95a92e7cf4e530faa49a765/src/code-stub-assembler.h>helper predicates</a> were already implemented in the assembler, which made the <a href=https://github.com/v8/v8/commit/f2af839b1938b55b4d32a2a1eb6704c49c8d877d#diff-ed49371933a938a7c9896878fd4e4919R97>initial version</a> concise and readable.<p>The figure below shows the execution flow for calling a Proxy with any proxy trap (in this example <code>apply</code>, which is being called when the proxy is used as a function) generated by the following sample code:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">…</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span><br><span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span> … <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>  <span class="token literal-property property">apply</span><span class="token operator">:</span> foo<span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">g</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><figure><img alt="" height=768 loading=lazy src=/_img/optimizing-proxies/0.png width=1024></figure><p>After porting the trap execution to CSA all of the execution happens in the JS runtime, reducing the number of jumps between languages from 4 to 0.<p>This change resulted in the following performance improvements::<figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/1.png width=1200></figure><p>Our JS performance score shows an improvement between <strong>49% and 74%</strong>. This score roughly measures how many times the given microbenchmark can be executed in 1000ms. For some tests the code is run multiple times in order to get an accurate enough measurement given the timer resolution. The code for all of the following benchmarks can be found <a href=https://github.com/v8/v8/blob/5a5783e3bff9e5c1c773833fa502f14d9ddec7da/test/js-perf-test/Proxies/proxies.js>in our js-perf-test directory</a>.<h2 id=call-and-construct-traps>Call and construct traps <a href=#call-and-construct-traps class=bookmark>#</a></h2><p>The next section shows the results from optimizing call and construct traps (a.k.a. <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply><code>"apply"</code></a>" and <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct><code>"construct"</code></a>).<figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/2.png width=1200></figure><p>The performance improvements when <em>calling</em> proxies are significant — up to <strong>500%</strong> faster! Still, the improvement for proxy construction is quite modest, especially in cases where no actual trap is defined — only about <strong>25%</strong> gain. We investigated this by running the following command with the <a href=/docs/build><code>d8</code> shell</a>:<pre class=language-bash><code class=language-bash>$ out/x64.release/d8 --runtime-call-stats test.js<br><span class="token operator">></span> run: <span class="token number">120.104000</span><br><br>                      Runtime Function/C++ Builtin        Time             Count<br><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><br>                                         NewObject     <span class="token number">59</span>.16ms  <span class="token number">48.47</span>%    <span class="token number">100000</span>  <span class="token number">24.94</span>%<br>                                      JS_Execution     <span class="token number">23</span>.83ms  <span class="token number">19.53</span>%         <span class="token number">1</span>   <span class="token number">0.00</span>%<br>                              RecompileSynchronous     <span class="token number">11</span>.68ms   <span class="token number">9.57</span>%        <span class="token number">20</span>   <span class="token number">0.00</span>%<br>                        AccessorNameGetterCallback     <span class="token number">10</span>.86ms   <span class="token number">8.90</span>%    <span class="token number">100000</span>  <span class="token number">24.94</span>%<br>      AccessorNameGetterCallback_FunctionPrototype      <span class="token number">5</span>.79ms   <span class="token number">4.74</span>%    <span class="token number">100000</span>  <span class="token number">24.94</span>%<br>                                  Map_SetPrototype      <span class="token number">4</span>.46ms   <span class="token number">3.65</span>%    <span class="token number">100203</span>  <span class="token number">25.00</span>%<br>… SNIPPET …</code></pre><p>Where <code>test.js</code>’s source is:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> <span class="token constant">N</span> <span class="token operator">=</span> <span class="token number">1e5</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'run'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">N</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'run'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>It turned out most of the time is spent in <code>NewObject</code> and the functions called by it, so we started planning how to speed this up in future releases.<h2 id=get-trap>Get trap <a href=#get-trap class=bookmark>#</a></h2><p>The next section describes how we optimized the other most common operations — getting and setting properties through proxies. It turned out the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get><code>get</code></a> trap is more involved than the previous cases, due to the specific behavior of V8's inline cache. For a detailed explanation of inline caches, you can watch <a href="https://www.youtube.com/watch?v=u7zRSm8jzvA">this talk</a>.<p>Eventually we managed to get a working port to CSA with the following results:<figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/3.png width=1200></figure><p>After landing the change, we noticed the size of the Android <code>.apk</code> for Chrome had grown by <strong>~160KB</strong>, which is more than expected for a helper function of roughly 20 lines, but fortunately we track such statistics. It turned out this function is called twice from another function, which is called 3 times, from another called 4 times. The cause of the problem turned out to be the aggressive inlining. Eventually we solved the issue by turning the inline function into a separate code stub, thus saving precious KBs — the end version had only <strong>~19KB</strong> increase in <code>.apk</code> size.<h2 id=has-trap>Has trap <a href=#has-trap class=bookmark>#</a></h2><p>The next section shows the results from optimizing the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has><code>has</code></a> trap. Although at first we thought it would be easier (and reuse most of the code of the <code>get</code> trap), it turned out to have its own peculiarities. A particularly hard-to-track-down problem was the prototype chain walking when calling the <code>in</code> operator. The improvement results achieved vary between <strong>71% and 428%</strong>. Again the gain is more prominent in cases where the trap is present.<figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/4.png width=1200></figure><h2 id=set-trap>Set trap <a href=#set-trap class=bookmark>#</a></h2><p>The next section talks about porting the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set><code>set</code></a> trap. This time we had to differentiate between <a href=/blog/fast-properties>named</a> and indexed properties (<a href=/blog/elements-kinds>elements</a>). These two main types are not part of the JS language, but are essential for V8's efficient property storage. The initial implementation still bailed out to the runtime for elements, which causes crossing the language boundaries again. Nevertheless we achieved improvements between <strong>27% and 438%</strong> for cases when the trap is set, at the cost of a decrease of up to <strong>23%</strong> when it's not. This performance regression is due to the overhead of additional check for differentiating between indexed and named properties. For indexed properties, there is no improvement yet. Here are the complete results:<figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/5.png width=1200></figure><h2 id=real-world-usage>Real-world usage <a href=#real-world-usage class=bookmark>#</a></h2><h3 id=results-from-jsdom-proxy-benchmark>Results from <a href=https://github.com/domenic/jsdom-proxy-benchmark>jsdom-proxy-benchmark</a> <a href=#results-from-jsdom-proxy-benchmark class=bookmark>#</a></h3><p>The jsdom-proxy-benchmark project compiles the <a href=https://github.com/tc39/ecma262>ECMAScript specification</a> using the <a href=https://github.com/bterlson/ecmarkup>Ecmarkup</a> tool. As of <a href=https://github.com/tmpvar/jsdom/blob/master/Changelog.md#1120>v11.2.0</a>, the jsdom project (which underlies Ecmarkup) uses proxies to implement the common data structures <code>NodeList</code> and <code>HTMLCollection</code>. We used this benchmark to get an overview of some more realistic usage than the synthetic micro-benchmarks, and achieved the following results, average of 100 runs:<ul><li>Node v8.4.0 (without Proxy optimizations): <strong>14277 ± 159 ms</strong><li><a href=https://nodejs.org/download/v8-canary/v9.0.0-v8-canary20170924898da64843/node-v9.0.0-v8-canary20170924898da64843-linux-x64.tar.gz>Node v9.0.0-v8-canary-20170924</a> (with only half of the traps ported): <strong>11789 ± 308 ms</strong><li>Gain in speed around 2.4 seconds which is <strong>~17% better</strong></ul><figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/6.png width=1200></figure><ul><li><a href=https://github.com/domenic/jsdom-proxy-benchmark/issues/1#issuecomment-329047990>Converting <code>NamedNodeMap</code> to use <code>Proxy</code></a> increased processing time by<ul><li><strong>1.9 s</strong> on V8 6.0 (Node v8.4.0)<li><strong>0.5 s</strong> on V8 6.3 (Node v9.0.0-v8-canary-20170910)</ul></ul><figure><img alt="" height=634 loading=lazy src=/_img/optimizing-proxies/7.png width=1028></figure><div class=note><p><strong>Note:</strong> These results were provided by <a href=https://github.com/TimothyGu>Timothy Gu</a>. Thanks!</div><h3 id=results-from-chai.js>Results from <a href=https://chaijs.com/ >Chai.js</a> <a href=#results-from-chai.js class=bookmark>#</a></h3><p>Chai.js is a popular assertion library which makes heavy use of proxies. We've created a kind of real-world benchmark by running its tests with different versions of V8 an improvement of roughly <strong>1s out of more than 4s</strong>, average of 100 runs:<ul><li>Node v8.4.0 (without Proxy optimizations): <strong>4.2863 ± 0.14 s</strong><li><a href=https://nodejs.org/download/v8-canary/v9.0.0-v8-canary20170924898da64843/node-v9.0.0-v8-canary20170924898da64843-linux-x64.tar.gz>Node v9.0.0-v8-canary-20170924</a> (with only half of the traps ported): <strong>3.1809 ± 0.17 s</strong></ul><figure><img alt="" height=742 loading=lazy src=/_img/optimizing-proxies/8.png width=1200></figure><h2 id=optimization-approach>Optimization approach <a href=#optimization-approach class=bookmark>#</a></h2><p>We often tackle performance issues using a generic optimization scheme. The main approach that we followed for this particular work included the following steps:<ul><li>Implement performance tests for the particular sub-feature<li>Add more specification conformance tests (or write them from scratch)<li>Investigate the original C++ implementation<li>Port the sub-feature to the platform-agnostic CodeStubAssembler<li>Optimize the code even further by hand-crafting a <a href=/docs/turbofan>TurboFan</a> implementation<li>Measure the performance improvement.</ul><p>This approach can be applied to any general optimization task that you may have.</div><footer><div><picture><source srcset="/_img/avatars/maya-armyanova.avif, /_img/avatars/maya-armyanova@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/maya-armyanova.jpg width=96 srcset="/_img/avatars/maya-armyanova@2x.jpg 2x"></picture><p>作者：Maya Armyanova (<a href=https://twitter.com/Zmayski>@Zmayski</a>), Optimizer of Proxies.</div><a href=https://twitter.com/v8js/status/915846050447003648 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/optimizing-proxies>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/optimizing-proxies.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
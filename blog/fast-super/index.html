<!doctype html><html lang=zh-CN><meta charset=utf-8><title>超快的 super 属性访问 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Faster super property access in V8 v9.0" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>超快的 <code>super</code> 属性访问</h1><p class=meta>发布时间 <time datetime="2021-02-18 00:00:00" itemprop=datePublished title="2021-02-18 00:00:00">2021-02-18</time> · 标签： <a href=/blog/tags/javascript/ class=tag>JavaScript</a></header><div itemprop=articleBody><p><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super><code>super</code> 关键字</a>可用于访问对象的父对象的属性和函数。<p>以前，访问 super 属性（如 <code>super.x</code>）是通过运行时调用实现的。 从 V8 v9.0 开始，我们在未优化的代码中重用了<a href=https://mathiasbynens.be/notes/shapes-ics>内联缓存 (IC) 系统</a>，并生成了用于 super 属性访问的应有的优化代码，而不必跳到运行时。<p>从下图中可以看到，由于运行时调用，super 属性访问曾经比普通属性访问慢一个数量级。现在，我们已经接近同等水平。<figure><img alt="" height=371 loading=lazy src=/_img/fast-super/super-opt.svg width=600><figcaption>将 super 属性访问与常规属性访问进行比较（已优化）</figcaption></figure><figure><img alt="" height=371 loading=lazy src=/_img/fast-super/super-no-opt.svg width=600><figcaption>将 super 属性访问与常规属性访问进行比较（未优化）</figcaption></figure><p>Super 属性访问很难进行基准测试，因为它必须发生在函数内部。我们无法对单个属性访问进行基准测试，而只能针对更大范围的工作。因此，函数调用开销包含在测量中。上面的图表在某种程度上低估了 super 属性访问和普通属性访问之间的区别，但它们的准确性足以说明新旧 super 属性访问之间的区别。<p>在未优化（解释）模式下，super 属性访问将总是比普通属性访问慢，因为我们需要做更多的工作（从上下文读取主对象，并从主对象读取 <code>__proto__</code>）。在优化的代码中，我们已经尽可能将主对象（home object）作为常量嵌入。也可以通过将其 <code>__proto__</code> 嵌入为常量来进一步改进。<h3 id=prototypal-inheritance-and-super>原型继承和 <code>super</code> <a href=#prototypal-inheritance-and-super class=bookmark>#</a></h3><p>让我们从基础开始 - super 属性访问真正意味着什么？<pre class=language-javascript><code class=language-javascript><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><br><span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><br><br><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><br>  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>b<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>现在，<code>A</code> 是 <code>B</code> 的超类，<code>b.m()</code> 会按预期返回 <code>100</code>。<figure><img alt="" height=147 loading=lazy src=/_img/fast-super/inheritance-1.svg width=100><figcaption>类继承图</figcaption></figure><p>现实是 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain>JavaScript 的原型继承</a>更加复杂：<figure><img alt="" height=284 loading=lazy src=/_img/fast-super/inheritance-2.svg width=435><figcaption>原型继承图</figcaption></figure><p>我们需要仔细区分 <code>__proto__</code> 和 <code>prototype</code> 属性 - 它们并不代表同样的含义！让人更困惑的是，对象 <code>b.__proto__</code> 通常被称为“<code>b</code> 的原型”。<p><code>b.__proto__</code> 对象是 <code>b</code> 的继承属性。<code>B.prototype</code> 作为使用 <code>new B()</code> 创建的对象的 <code>__proto__</code> 对象，即 <code>b.__proto__ === B.prototype</code>。<p>反过来，<code>B.prototype</code> 具有自己的 <code>__proto__</code> 属性，该属性等于 <code>A.prototype</code>。这些共同构成了所谓的原型链：<pre><code>b ->
 b.__proto__ === B.prototype ->
  B.prototype.__proto__ === A.prototype ->
   A.prototype.__proto__ === Object.prototype ->
    Object.prototype.__proto__ === null
</code></pre><p>通过该链，<code>b</code> 可以访问在任何这些对象中定义的所有属性。方法 <code>m</code> 是 <code>B.prototype</code>的属性（即 <code>B.prototype.m</code>），这就是 <code>b.m()</code> 起作用的原因。<p>现在，我们可以将 <code>m</code> 内的 <code>super.x</code> 定义为属性查找（property lookup），在该属性查找中，我们开始在<em>主对象（home object）</em> 的 <code>__proto__</code> 中查找属性 <code>x</code>，并沿着原型链向上移动直到找到它。<p>主对象（home object）是定义方法的对象 - 在这种情况下，<code>m</code> 的主对象是 <code>B.prototype</code>。它的 <code>__proto__</code> 是 <code>A.prototype</code>，因此我们从这里开始寻找属性 <code>x</code>。 我们将 <code>A.prototype</code> 称为<em>查找起始对象（lookup start object）</em>。在这种情况下，我们可以在查找起始对象中立即找到属性 <code>x</code>，但通常它也可能位于原型链的更远处。<p>如果 <code>B.prototype</code> 具有一个名为 <code>x</code> 的属性，我们将忽略它，因为我们开始在原型链中的上方寻找它。另外，在这种情况下，超级属性查询不依赖于<em>接收者（receiver）</em>，即调用该方法时 <code>this</code> 值指向的对象。<pre class=language-javascript><code class=language-javascript><span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>some_other_object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// still returns 100</span></code></pre><p>如果该属性具有读取器（getter），则接收者（receiver）将作为 <code>this</code> 值传递给读取器。<p>总结一下：在 super 属性访问 <code>super.x</code> 中，查找起始对象是主对象的 <code>__proto__</code>，接收者是发生 super 属性访问的方法的接收者。<p>在普通的属性访问 <code>o.x</code> 中，我们开始在 <code>o</code> 中寻找属性 <code>x</code>，然后到原型链上。如果 <code>x</code> 恰好有一个读取器，我们还将使用 <code>o</code> 作为接收者 - 查找起始对象和接收者是同一对象（<code>o</code>）。<p><em>Super 属性访问就像常规属性访问一样，其中查找起始对象（lookup start object）和接收者（receiver）不同。</em><h3 id=implementing-faster-super>实现更快的 <code>super</code> <a href=#implementing-faster-super class=bookmark>#</a></h3><p>以上的分析结论也是实现快速 super 属性访问的关键。V8 已经过设计，可以快速进行属性访问 - 现在，我们针对接收者和查找起始对象不同的情况将其通用化。<p>V8 的数据驱动的内联缓存系统是实现快速属性访问的核心部分。你可以在<a href=https://mathiasbynens.be/notes/shapes-ics>高级介绍</a>中阅读相关内容，也可以了解 <a href=https://v8.dev/blog/fast-properties>V8 的对象表示</a>以及 <a href="https://docs.google.com/document/d/1mEhMn7dbaJv68lTAvzJRCQpImQoO6NZa61qRimVeA-k/edit?usp=sharing">V8 的数据驱动的内联缓存系统是如何实现的</a> 更多的细节描述。<p>为了提高 <code>super</code> 性能，我们添加了一个新的 <a href=https://v8.dev/docs/ignition>Ignition</a> 节代码 <code>LdaNamedPropertyFromSuper</code>，它使我们能够以解释模式插入 IC 系统，并生成用于 super 属性访问的优化代码。<p>使用新的字节码，我们可以添加新的 IC，<code>LoadSuperIC</code>，以加速 super 属性加载。与处理正常属性加载的 <code>LoadIC</code> 相似，<code>LoadSuperIC</code> 会跟踪已看到的查找起始对象的形状（shapes），并记住如何从具有这些形状之一的对象中加载属性。<p><code>LoadSuperIC</code> 将现有的 IC 机制重新用于属性加载，只是具有不同的查找起始对象。由于 IC 层已经在查找起始对象和接收者之间进行了区分，因此实现起来应该很容易。但是，由于查找起始对象和接收者始终是相同的，因此即使我们指的是接收者，也存在一些使用查找起始对象的错误，反之亦然。这些错误已得到修复，现在我们可以正确的支持查找起始对象和接收者不同的情况。<p>用于 super 属性访问的优化代码由 <a href=https://v8.dev/docs/turbofan>TurboFan</a> 编译器的 <code>JSNativeContextSpecialization</code> 阶段生成。该实现概括了现有的属性查找机制（<a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/compiler/js-native-context-specialization.cc;l=1130"><code>JSNativeContextSpecialization::ReduceNamedAccess</code></a>），以处理接收者和查找起始对象不同的情况。<p>当我们将主对象从存储它的 <code>JSFunction</code> 中移出时，优化的代码变得更加优化。现在，它存储在类上下文中，这使 TurboFan 尽可能将其作为常量嵌入到优化的代码中。<h2 id=other-usages-of-super><code>super</code> 的其它用法 <a href=#other-usages-of-super class=bookmark>#</a></h2><p><code>super</code> 在对象字面（literal）方法内部的工作方式与类方法内部相同，并且进行了类似的优化。<pre class=language-javascript><code class=language-javascript><span class="token keyword">const</span> myproto <span class="token operator">=</span> <span class="token punctuation">{</span><br>  __proto__<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">'x'</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> __proto__<span class="token operator">:</span> myproto <span class="token punctuation">}</span><span class="token punctuation">;</span><br>o<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 100</span></code></pre><p>当然，有些情况我们没有进行优化。例如，写入 super 属性（<code>super.x = ...</code>）并未得到优化。此外，使用 mixins 会使 access site 变成 megamorphic，从而导致 super 属性访问速度变慢：<pre class=language-javascript><code class=language-javascript><span class="token keyword">function</span> <span class="token function">createMixin</span><span class="token punctuation">(</span><span class="token parameter">base</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">class</span> <span class="token class-name">Mixin</span> <span class="token keyword">extends</span> <span class="token class-name">base</span> <span class="token punctuation">{</span><br>    <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br>    <span class="token comment">//                ^ this access site is megamorphic</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> Mixin<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><br>  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> myClass <span class="token operator">=</span> <span class="token function">createMixin</span><span class="token punctuation">(</span><br>  <span class="token function">createMixin</span><span class="token punctuation">(</span><br>    <span class="token function">createMixin</span><span class="token punctuation">(</span><br>      <span class="token function">createMixin</span><span class="token punctuation">(</span><br>        <span class="token function">createMixin</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><br>      <span class="token punctuation">)</span><br>    <span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">myClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>要确保所有面向对象的模式都尽可能快，还有很多工作要做 - 敬请期待进一步的优化！</div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/marja-holtta.jpg width=96 srcset="/_img/avatars/marja-holtta@2x.jpg 2x"></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, super optimizer.</div><a href=https://twitter.com/v8js/status/1362465295848333316 class=retweet>Retweet this article!</a></footer><footer><div><p>译者：不如怀念 (<a href=https://github.com/wang1212>@wang1212</a>).</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/fast-super>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/fast-super.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
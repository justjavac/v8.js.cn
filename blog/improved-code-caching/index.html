<!doctype html><html lang=zh-CN><meta charset=utf-8><title>改进代码缓存 · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="从 Chrome 66 开始，V8 可以把执行过的代码缓存起来" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>改进代码缓存</h1><p class=meta>发布时间 <time datetime="2018-04-24 13:33:37" itemprop=datePublished title="2018-04-24 13:33:37">2018-04-24</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>在 V8 中，当某些脚本经常使用时，V8 会把这些脚本生产的<a href=/blog/code-caching>代码缓存</a>起来。从 Chrome 66 开始，当引擎在顶层执行后，我们会把生成的更多代码缓存起来。这会导致初始加载时分析和编译时间缩短 20-40%。<h2 id=background>背景 <a href=#background class=bookmark>#</a></h2><p>V8 使用两种代码缓存策略来缓存生成的代码，以便以后重用。首先是存在于每个 V8 实例中的内存缓存（in-memory cache）。初始编译后生成的代码存储在此缓存中，以源字符串作为 key。这可以在 V8 的相同实例中重复使用。另一种代码缓存序列化生成的代码并将其存储在磁盘上供将来使用。该缓存并不只属于 V8 的特定实例，可以在 V8 的不同实例中使用。这篇博文主要关注 Chrome 中使用的第二种代码缓存。（其他嵌入程序也使用这种代码缓存;它不仅限于 Chrome，但本博文仅关注 Chrome 中的使用情况。）<p>Chrome 将序列化的生成代码（generated code）存储到磁盘缓存中，并使用脚本资源的 URL 作为 key。加载脚本时，Chrome 会检查磁盘缓存。如果脚本已被缓存，则 Chrome 会将序列化的数据作为编译请求的一部分传递给 V8。然后 V8 反序列化这些数据，而不是解析和编译脚本。还有额外的检查来确保代码仍然可用（例如：版本不匹配导致缓存的数据无法使用）。<p>真实世界的数据显示，代码缓存命中率（对于可以缓存的脚本）很高（~86%）。虽然这些脚本的缓存命中率很高，但是我们每个脚本缓存的代码量并不是很高。我们的分析表明，增加缓存的代码量可以使 JavaScript 代码的解析和编译减少大约 40% 的时间。<h2 id=increasing-the-amount-of-code-that-is-cached>增加缓存的代码量 <a href=#increasing-the-amount-of-code-that-is-cached class=bookmark>#</a></h2><p>在以前的方法中，代码缓存与脚本的编译请求相结合。<p>嵌入者可以请求 V8 序列化它在顶级编译新的 JavaScript 源文件时生成的代码。编译脚本后，V8 返回序列化代码。当 Chrome 再次请求相同的脚本时，V8 会从缓存中获取序列化的代码并对其进行反序列化。V8 完全避免了重新编译已经在缓存中的函数。下图显示了这些场景：<figure><img alt="" height=195 src=/_img/improved-code-caching/warm-hot-run-1.png width=624 loading=lazy></figure><p>V8 仅编译在顶层编译期间的立即执行的函数（IIFE），并标记用于延迟编译的其他函数。这样可以避免编译不需要的函数，从而提高页面加载时间，但这也意味着序列化数据仅包含需要迫切编译的函数的代码。<p>在 Chrome 59 之前，我们必须在代码开始执行之前生成代码缓存。较早的 V8 基本编译器（Full-codegen）为执行上下文生成专用代码。Full-codegen 将代码补丁用于特定执行上下文的快速路径（fast-path）操作。当在其他执行上下文中使用的，需要删除特定于某个上下文的数据，此类代码不能被轻易地序列化。<p>随着在 Chrome 59 中<a href=/blog/launching-ignition-and-turbofan>启用 Ignition</a>，这一限制不再是必要的。Ignition 使用<a href="https://www.youtube.com/watch?v=u7zRSm8jzvA">数据驱动的内嵌缓存</a>来执行当前执行上下文中的快速路径操作。上下文相关数据存储在反馈向量（feedback vector）中并与生成的代码分开。通过这种方式也就使得“执行脚本之后也能生成代码缓存”称为可能。在我们执行脚本时，会编译更多的函数（标记为惰性编译的函数），从而允许我们缓存更多的代码。<p>V8 公开了一个新 API，<code>ScriptCompiler::CreateCodeCache</code>，可以让代码缓存请求不再依赖于编译请求。在编译请求的过程中请求代码缓存已被弃用，并且不适用于 V8 v6.6 及更高版本。从版本 66 开始，Chrome 使用此 API 在顶层执行后请求代码缓存。下图显示了请求代码缓存的新场景。代码缓存在顶层执行之后被请求，并因此包含在脚本执行期间稍后被编译的函数的代码。在后面的运行中（在下图中显示为热运行），它避免了在顶层执行期间编译函数。<figure><img alt="" height=191 src=/_img/improved-code-caching/warm-hot-run-2.png width=624 loading=lazy></figure><h2 id=results>结果 <a href=#results class=bookmark>#</a></h2><p>使用我们内部的 <a href="https://cs.chromium.org/chromium/src/tools/perf/page_sets/v8_top_25.py?q=v8.top&sq=package:chromium&l=1">real-world benchmarks</a> 测试此功能的性能。下图显示了早期高速缓存方案中分析和编译时间的缩短。在大多数页面上，解析和编译时间都会减少 20-40% 左右。<figure><img alt="" height=946 src=/_img/improved-code-caching/parse.png width=1530 loading=lazy></figure><figure><img alt="" height=946 src=/_img/improved-code-caching/compile.png width=1532 loading=lazy></figure><p>来自其它数据也显示了和我们相似的结果，在桌面和移动设备上编译 JavaScript 代码的时间减少了 20-40%。在 Android 上，这种优化还可以转化为顶级页面加载指标减少 1-2%，例如网页可以被用户操作时所需的时间。我们还监测了 Chrome 的内存和磁盘使用情况，但没有看到任何明显的回归。</div><footer><div><picture><source srcset="/_img/avatars/mythri-alle.avif, /_img/avatars/mythri-alle@2x.avif 2x" type=image/avif><img alt="" height=96 src=/_img/avatars/mythri-alle.jpg width=96 loading=lazy srcset="/_img/avatars/mythri-alle@2x.jpg 2x"></picture><p>作者：Mythri Alle, Chief Code Cacher.</div><a href=https://twitter.com/v8js/status/988728000677142528 class=retweet>Retweet this article!</a></footer><footer><div><img alt="" height=96 src=/_img/avatars/justjavac.jpg width=96 srcset="/_img/avatars/justjavac@2x.jpg 2x" lazyload=on><p>译者：迷渡 (<a href=https://github.com/justjavac>@justjavac</a>)，V8.js.cn 站长.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/improved-code-caching>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/improved-code-caching.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
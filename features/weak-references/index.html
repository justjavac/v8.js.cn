<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Weak references and finalizers · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/_css/feature-support.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Weak references and finalizers are coming to JavaScript! This article explains the new functionality." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li class=current><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Weak references and finalizers</h1><p class=meta>发布时间 <time datetime="2019-07-09 00:00:00" itemprop=datePublished>2019-07-09</time> · 更新时间 <time datetime="2020-06-19 00:00:00" itemprop=dateModified>2020-06-19</time> · 标签： <a href=/features/tags/ecmascript class=tag>ECMAScript</a> <a href=/features/tags/es2021 class=tag>ES2021</a></header><div itemprop=articleBody><p>Generally, references to objects are <em>strongly held</em> in JavaScript, meaning that as long you have a reference to the object, it won’t be garbage-collected.<pre class=language-js><code class=language-js><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">51</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token comment">// As long as you have access to `ref` (or any other reference to the</span><br><span class="token comment">// same object), the object won’t be garbage-collected.</span></code></pre><p>Currently, <code>WeakMap</code>s and <code>WeakSet</code>s are the only way to kind-of-weakly reference an object in JavaScript: adding an object as a key to a <code>WeakMap</code> or <code>WeakSet</code> doesn’t prevent it from being garbage-collected.<pre class=language-js><code class=language-js><span class="token keyword">const</span> wm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">{</span><br>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> metaData <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span><br>  wm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> metaData<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  wm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// → metaData</span><br><span class="token punctuation">}</span><br><span class="token comment">// We no longer have a reference to `ref` in this block scope, so it</span><br><span class="token comment">// can be garbage-collected now, even though it’s a key in `wm` to</span><br><span class="token comment">// which we still have access.</span><br><br><span class="token keyword">const</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">{</span><br>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>  ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// → true</span><br><span class="token punctuation">}</span><br><span class="token comment">// We no longer have a reference to `ref` in this block scope, so it</span><br><span class="token comment">// can be garbage-collected now, even though it’s a key in `ws` to</span><br><span class="token comment">// which we still have access.</span></code></pre><div class=note><p><strong>Note:</strong> You can think of <code>WeakMap.prototype.set(ref, metaData)</code> as adding a property with the value <code>metaData</code> to the object <code>ref</code>: as long as you have a reference to the object, you can get the metadata. Once you no longer have a reference to the object, it can be garbage-collected, even if you still have a reference to the <code>WeakMap</code> to which it was added. Similarly, you can think of a <code>WeakSet</code> as a special case of <code>WeakMap</code> where all the values are booleans.<p>A JavaScript <code>WeakMap</code> is not really <em>weak</em>: it actually refers <em>strongly</em> to its contents as long as the key is alive. The <code>WeakMap</code> only refers weakly to its contents once the key is garbage-collected. A more accurate name for this kind of relationship is <a href=https://en.wikipedia.org/wiki/Ephemeron><em>ephemeron</em></a>.</div><p><code>WeakRef</code> is a more advanced API that provides <em>actual</em> weak references, enabling a window into the lifetime of an object. Let’s walk through an example together.<p>For the example, suppose we’re working on a chat web application that uses web sockets to communicate with a server. Imagine a <code>MovingAvg</code> class that, for performance diagnostic purposes, keeps a set of events from a web socket in order to compute a simple moving average of the latency.<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">MovingAvg</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function function-variable">listener</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">compute</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Compute the simple moving average for the last n events.</span><br>    <span class="token comment">// …</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>It is used by a <code>MovingAvgComponent</code> class that lets you control when to start and stop monitoring the simple moving average of the latency.<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">MovingAvgComponent</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>movingAvg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MovingAvg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Allow the garbage collector to reclaim memory.</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>movingAvg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Do rendering.</span><br>    <span class="token comment">// …</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>We know that keeping all the server messages inside an instance <code>MovingAvg</code> uses a lot of memory, so we take care to null out <code>this.movingAvg</code> when monitoring is stopped to let the garbage collector reclaim memory.<p>However, after checking in the memory panel in DevTools, we found out that memory was not being reclaimed at all! The seasoned web developer may have already spotted the bug: event listeners are strong references and must be explicitly removed.<p>Let’s make this explicit with reachability diagrams. After calling <code>start()</code>, our object graph looks like the following, where a solid arrow means a strong reference. Everything reachable via solid arrows from the <code>MovingAvgComponent</code> instance is not garbage-collectible.<figure><img alt="" height=175 loading=lazy src=/_img/weakrefs/after-start.svg width=504></figure><p>After calling <code>stop()</code>, we’ve removed the strong reference from the <code>MovingAvgComponent</code> instance to the <code>MovingAvg</code> instance, but not via the socket’s listener.<figure><img alt="" height=175 loading=lazy src=/_img/weakrefs/after-stop.svg width=504></figure><p>Thus, the listener in <code>MovingAvg</code> instances, by referencing <code>this</code>, keeps the whole instance alive as long as the event listener isn't removed.<p>Until now, the solution is to manually unregister the event listener via a <code>dispose</code> method.<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">MovingAvg</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function function-variable">listener</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>socket<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre><p>The downside to this approach is that it is manual memory management. <code>MovingAvgComponent</code>, and all other users of the <code>MovingAvg</code> class, must remember to call <code>dispose</code> or suffer memory leaks. What’s worse, manual memory management is cascading: users of <code>MovingAvgComponent</code> must remember to call <code>stop</code> or suffer memory leaks, so on and so forth. The application behavior doesn’t depend on the event listener of this diagnostic class, and the listener is expensive in terms of memory use but not in computation. What we really want is for the listener’s lifetime to be logically tied to the <code>MovingAvg</code> instance, so that <code>MovingAvg</code> could be used like any other JavaScript object whose memory is automatically reclaimed by the garbage collector.<p><code>WeakRef</code>s make it possible to solve the dilemma by creating a <em>weak reference</em> to the actual event listener, and then wrapping that <code>WeakRef</code> in an outer event listener. This way, the garbage collector can clean up the actual event listener and the memory that it holds alive, like the <code>MovingAvg</code> instance and its <code>events</code> array.<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">addWeakListener</span><span class="token punctuation">(</span><span class="token parameter">socket<span class="token punctuation">,</span> listener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakRef</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> <span class="token function function-variable">wrapper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> weakRef<span class="token punctuation">.</span><span class="token function">deref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?.</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">MovingAvg</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function function-variable">listener</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token function">addWeakListener</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><div class=note><p><strong>Note:</strong> <code>WeakRef</code>s to functions must be treated with caution. JavaScript functions are <a href=https://en.wikipedia.org/wiki/Closure_(computer_programming)>closures</a> and strongly reference the outer environments which contain the values of free variables referenced inside the functions. These outer environments may contain variables that <em>other</em> closures reference as well. That is, when dealing with closures, their memory is often strongly referenced by other closures in subtle ways. This is the reason <code>addWeakListener</code> is a separate function and <code>wrapper</code> is not local to the <code>MovingAvg</code> constructor. In V8, if <code>wrapper</code> were local to the <code>MovingAvg</code> constructor and shared the lexical scope with the listener that is wrapped in the <code>WeakRef</code>, the <code>MovingAvg</code> instance and all its properties become reachable via the shared environment from the wrapper listener, causing the instance to be uncollectible. Keep this in mind when writing code.</div><p>We first make the event listener and assign it to <code>this.listener</code>, so that it is strongly referenced by the <code>MovingAvg</code> instance. In other words, as long as the <code>MovingAvg</code> instance is alive, so is the event listener.<p>Then, in <code>addWeakListener</code>, we create a <code>WeakRef</code> whose <em>target</em> is the actual event listener. Inside <code>wrapper</code>, we <code>deref</code> it. Because <code>WeakRef</code>s do not prevent garbage collection of their targets if the targets do not have other strong references, we must manually dereference them to get the target. If the target has been garbage-collected in the meantime, <code>deref</code> returns <code>undefined</code>. Otherwise, the original target is returned, which is the <code>listener</code> function we then call using <a href=/features/optional-chaining>optional chaining</a>.<p>Since the event listener is wrapped in a <code>WeakRef</code>, the <em>only</em> strong reference to it is the <code>listener</code> property on the <code>MovingAvg</code> instance. That is, we’ve successfully tied the lifetime of the event listener to the lifetime of the <code>MovingAvg</code> instance.<p>Returning to reachability diagrams, our object graph looks like the following after calling <code>start()</code> with the <code>WeakRef</code> implementation, where a dotted arrow means a weak reference.<figure><img alt="" height=175 loading=lazy src=/_img/weakrefs/weak-after-start.svg width=723></figure><p>After calling <code>stop()</code>, we’ve removed the only strong reference to the listener:<figure><img alt="" height=175 loading=lazy src=/_img/weakrefs/weak-after-stop.svg width=723></figure><p>Eventually, after a garbage collection occurs, the <code>MovingAvg</code> instance and the listener will be collected:<figure><img alt="" height=175 loading=lazy src=/_img/weakrefs/weak-after-gc.svg width=723></figure><p>But there’s still a problem here: we’ve added a level of indirection to <code>listener</code> by wrapping it a <code>WeakRef</code>, but the wrapper in <code>addWeakListener</code> is still leaking for the same reason that <code>listener</code> was leaking originally. Granted, this is a smaller leak since only the wrapper is leaking instead of the whole <code>MovingAvg</code> instance, but it is still a leak. The solution to this is the companion feature to <code>WeakRef</code>, <code>FinalizationRegistry</code>. With the new <code>FinalizationRegistry</code> API, we can register a callback to run when the garbage collector zaps a register object. Such callbacks are known as <em>finalizers</em>.<div class=note><p><strong>Note:</strong> The finalization callback does not run immediately after garbage-collecting the event listener, so don't use it for important logic or metrics. The timing of garbage collection and finalization callbacks is unspecified. In fact, an engine that never garbage-collects would be fully compliant. However, it's safe to assume that engines <em>will</em> garbage collect, and finalization callbacks will be called at some later time, unless the environment is discarded (such as the tab closing, or the worker terminating). Keep this uncertainty in mind when writing code.</div><p>We can register a callback with a <code>FinalizationRegistry</code> to remove <code>wrapper</code> from the socket when the inner event listener is garbage-collected. Our final implementation looks like this:<pre class=language-js><code class=language-js><span class="token keyword">const</span> gListenersRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizationRegistry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> socket<span class="token punctuation">,</span> wrapper <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  socket<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">function</span> <span class="token function">addWeakListener</span><span class="token punctuation">(</span><span class="token parameter">socket<span class="token punctuation">,</span> listener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakRef</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><br>  <span class="token keyword">const</span> <span class="token function function-variable">wrapper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> weakRef<span class="token punctuation">.</span><span class="token function">deref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?.</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><br>  gListenersRegistry<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> <span class="token punctuation">{</span> socket<span class="token punctuation">,</span> wrapper <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span><br>  socket<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">MovingAvg</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function function-variable">listener</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><br>    <span class="token function">addWeakListener</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><div class=note><p><strong>Note:</strong> <code>gListenersRegistry</code> is a global variable to ensure the finalizers are executed. A <code>FinalizationRegistry</code> is not kept alive by objects that are registered on it. If a registry is itself garbage-collected, its finalizer may not run.</div><p>We make an event listener and assign it to <code>this.listener</code> so that it is strongly referenced by the <code>MovingAvg</code> instance (1). We then wrap the event listener that does the work in a <code>WeakRef</code> to make it garbage-collectible, and to not leak its reference to the <code>MovingAvg</code> instance via <code>this</code> (2). We make a wrapper that <code>deref</code> the <code>WeakRef</code> to check if it is still alive, then call it if so (3). We register the inner listener on the <code>FinalizationRegistry</code>, passing a <em>holding value</em> <code>{ socket, wrapper }</code> to the registration (4). We then add the returned wrapper as an event listener on <code>socket</code> (5). Sometime after the <code>MovingAvg</code> instance and the inner listener are garbage-collected, the finalizer may run, with the holding value passed to it. Inside the finalizer, we remove the wrapper as well, making all memory associated with the use of a <code>MovingAvg</code> instance garbage-collectible (6).<p>With all this, our original implementation of <code>MovingAvgComponent</code> neither leaks memory nor requires any manual disposal.<h2 id=progressive-enhancement>Don’t overdo it <a href=#progressive-enhancement class=bookmark>#</a></h2><p>After hearing about these new capabilities, it might be tempting to <code>WeakRef</code> All The Things™. However, that’s probably not a good idea. Some things are explicitly <em>not</em> good use cases for <code>WeakRef</code>s and finalizers.<p>In general, avoid writing code that depends on the garbage collector cleaning up a <code>WeakRef</code> or calling a finalizer at any predictable time — <a href=https://github.com/tc39/proposal-weakrefs#a-note-of-caution>it can’t be done</a>! Moreover, whether an object is garbage-collectible at all may depend on implementation details, such as the representation of closures, that are both subtle and may differ across JavaScript engines and even between different versions of the same engine. Specifically, finalizer callbacks:<ul><li>Might not happen immediately after garbage collection.<li>Might not happen in the same order as actual garbage collection.<li>Might not happen at all, e.g. if the browser window is closed.</ul><p>So, don’t place important logic in the code path of a finalizer. They're useful to perform clean-up in response to garbage-collection, but you can't reliably use them to, say, record meaningful metrics about memory usage. For that use case, see <a href=https://web.dev/monitor-total-page-memory-usage/ ><code>performance.measureUserAgentSpecificMemory</code></a>.<p><code>WeakRef</code>s and finalizers can help you save memory, and work best when used sparingly as a means of progressive enhancement. Since they’re power-user features, we expect most usage to happen within frameworks or libraries.<h2 id=support><code>WeakRef</code> support <a href=#support class=bookmark>#</a></h2><ul class=feature-support><li class="environment has-support has-link"><a href=https://v8.dev/blog/v8-release-84#weak-references-and-finalizers><span class="icon chrome">Chrome:</span> <span class=support>自 <span class=version>74</span> 版本开始支持</span></a><li class="environment has-support has-link"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1561074"><span class="icon firefox">Firefox:</span> <span class=support>自 <span class=version>79</span> 版本开始支持</span></a><li class="environment no-support"><span class="icon safari">Safari:</span> <span class=support>不支持</span><li class="environment has-support"><span class="icon nodejs">Node.js:</span> <span class=support>自 <span class=version>14.6.0</span> 版本开始支持</span><li class="environment no-support"><span class="icon babel">Babel:</span> <span class=support>不支持</span></ul><div class=feature-support-info><a href=/features/support>关于特性支持列表</a></div></div><footer><div><picture><source srcset="/_img/avatars/sathya-gunasekaran.avif, /_img/avatars/sathya-gunasekaran@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/sathya-gunasekaran.jpg width=96 srcset="/_img/avatars/sathya-gunasekaran@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/mathias-bynens.avif, /_img/avatars/mathias-bynens@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/mathias-bynens.jpg width=96 srcset="/_img/avatars/mathias-bynens@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/shu-yu-guo.avif, /_img/avatars/shu-yu-guo@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/shu-yu-guo.jpg width=96 srcset="/_img/avatars/shu-yu-guo@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/leszek-swirski.avif, /_img/avatars/leszek-swirski@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/leszek-swirski.jpg width=96 srcset="/_img/avatars/leszek-swirski@2x.jpg 2x"></picture><p>作者：Sathya Gunasekaran (<a href=https://twitter.com/_gsathya>@_gsathya</a>), Mathias Bynens (<a href=https://twitter.com/mathias>@mathias</a>), Shu-yu Guo (<a href=https://twitter.com/_shu>@_shu</a>), and Leszek Swirski (<a href=https://twitter.com/leszekswirski>@leszekswirski</a>).</div><a href=https://twitter.com/v8js/status/1148603966848151553 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/features/weak-references>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/features/weak-references.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Subsume JSON a.k.a. JSON âŠ‚ ECMAScript Â· V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/_css/feature-support.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="JSON is now a syntactic subset of ECMAScript." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>æ˜¾ç¤ºå¯¼è‚®</a><nav><ul><li><a href=/ >ä¸»é¡µ</a><li><a href=/blog/ >åšå®¢</a><li><a href=/docs/ >æ–‡æ¡£</a><li class=current><a href=/features title="JavaScript å’Œ WebAssembly çš„æ–°ç‰¹æ€§">JS/Wasm æ–°ç‰¹æ€§</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Subsume JSON a.k.a. JSON âŠ‚ ECMAScript</h1><p class=meta>å‘å¸ƒæ—¶é—´ <time datetime="2019-08-14 00:00:00" itemprop=datePublished>2019-08-14</time> Â· æ ‡ç­¾ï¼š <a href=/features/tags/es2019 class=tag>ES2019</a></header><div itemprop=articleBody><p>With <a href=https://github.com/tc39/proposal-json-superset>the <em>JSON âŠ‚ ECMAScript</em> proposal</a>, JSON becomes a syntactic subset of ECMAScript. If youâ€™re surprised that this wasnâ€™t already the case, youâ€™re not alone!<h2 id=old>The old ES2018 behavior <a href=#old class=bookmark>#</a></h2><p>In ES2018, ECMAScript string literals couldnâ€™t contain unescaped U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR characters, because they are considered to be line terminators even in that context:<pre class=language-js><code class=language-js><span class="token comment">// A string containing a raw U+2028 character.</span><br><span class="token keyword">const</span> <span class="token constant">LS</span> <span class="token operator">=</span> <span class="token string">'â€¨'</span><span class="token punctuation">;</span><br><span class="token comment">// â†’ ES2018: SyntaxError</span><br><br><span class="token comment">// A string containing a raw U+2029 character, produced by `eval`:</span><br><span class="token keyword">const</span> <span class="token constant">PS</span> <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'"\u2029"'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// â†’ ES2018: SyntaxError</span></code></pre><p>This is problematic because JSON strings <em>can</em> contain these characters. As a result, developers had to implement specialized post-processing logic when embedding valid JSON into ECMAScript programs to handle these characters. Without such logic, the code would have subtle bugs, or even <a href=#security>security issues</a>!<h2 id=new>The new behavior <a href=#new class=bookmark>#</a></h2><p>In ES2019, string literals can now contain raw U+2028 and U+2029 characters, removing the confusing mismatch between ECMAScript and JSON.<pre class=language-js><code class=language-js><span class="token comment">// A string containing a raw U+2028 character.</span><br><span class="token keyword">const</span> <span class="token constant">LS</span> <span class="token operator">=</span> <span class="token string">'â€¨'</span><span class="token punctuation">;</span><br><span class="token comment">// â†’ ES2018: SyntaxError</span><br><span class="token comment">// â†’ ES2019: no exception</span><br><br><span class="token comment">// A string containing a raw U+2029 character, produced by `eval`:</span><br><span class="token keyword">const</span> <span class="token constant">PS</span> <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'"\u2029"'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// â†’ ES2018: SyntaxError</span><br><span class="token comment">// â†’ ES2019: no exception</span></code></pre><p>This small improvement greatly simplifies the mental model for developers (one less edge case to remember!), and reduces the need for specialized post-processing logic when embedding valid JSON into ECMAScript programs.<h2 id=embedding-json>Embedding JSON into JavaScript programs <a href=#embedding-json class=bookmark>#</a></h2><p>As a result of this proposal, <code>JSON.stringify</code> can now be used to generate valid ECMAScript string literals, object literals, and array literals. And because of the separate <a href=/features/well-formed-json-stringify><em>well-formed <code>JSON.stringify</code></em> proposal</a>, these literals can safely be represented in UTF-8 and other encodings (which is helpful if youâ€™re trying to write them to a file on disk). This is super useful for metaprogramming use cases, like dynamically creating JavaScript source code and writing it to disk.<p>Hereâ€™s an example of creating a valid JavaScript program embedding a given data object, taking advantage of the JSON grammar now being a subset of ECMAScript:<pre class=language-js><code class=language-js><span class="token comment">// A JavaScript object (or array, or string) representing some data.</span><br><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><br>  LineTerminators<span class="token operator">:</span> <span class="token string">'\n\râ€¨â€©'</span><span class="token punctuation">,</span><br>  <span class="token comment">// Note: the string contains 4 characters: '\n\r\u2028\u2029'.</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">// Turn the data into its JSON-stringified form. Thanks to JSON âŠ‚</span><br><span class="token comment">// ECMAScript, the output of `JSON.stringify` is guaranteed to be</span><br><span class="token comment">// a syntactically valid ECMAScript literal:</span><br><span class="token keyword">const</span> jsObjectLiteral <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Create a valid ECMAScript program that embeds the data as an object</span><br><span class="token comment">// literal.</span><br><span class="token keyword">const</span> program <span class="token operator">=</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">const data = </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> jsObjectLiteral <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">;</span><span class="token string template-punctuation">`</span></span><span class="token punctuation">;</span><br><span class="token comment">// â†’ 'const data = {"LineTerminators":"â€¦"};'</span><br><span class="token comment">// (Additional escaping is needed if the target is an inline &lt;script>.)</span><br><br><span class="token comment">// Write a file containing the ECMAScript program to disk.</span><br><span class="token function">saveToDisk</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> program<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The above script produces the following code, which evaluates to an equivalent object:<pre class=language-js><code class=language-js><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"LineTerminators"</span><span class="token operator">:</span><span class="token string">"\n\râ€¨â€©"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id=embedding-json-parse>Embedding JSON into JavaScript programs with <code>JSON.parse</code> <a href=#embedding-json-parse class=bookmark>#</a></h2><p>As explained in <a href=/blog/cost-of-javascript-2019#json><em>the cost of JSON</em></a>, instead of inlining the data as a JavaScript object literal, like so:<pre class=language-js><code class=language-js><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token number">1337</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ğŸŒ</span></code></pre><p>â€¦the data can be represented in JSON-stringified form, and then JSON-parsed at runtime, for improved performance in the case of large objects (10 kB+):<pre class=language-js><code class=language-js><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'{"foo":42,"bar":1337}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ğŸš€</span></code></pre><p>Hereâ€™s an example implementation:<pre class=language-js><code class=language-js><span class="token comment">// A JavaScript object (or array, or string) representing some data.</span><br><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><br>  LineTerminators<span class="token operator">:</span> <span class="token string">'\n\râ€¨â€©'</span><span class="token punctuation">,</span><br>  <span class="token comment">// Note: the string contains 4 characters: '\n\r\u2028\u2029'.</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token comment">// Turn the data into its JSON-stringified form.</span><br><span class="token keyword">const</span> json <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Now, we want to insert the JSON into a script body as a JavaScript</span><br><span class="token comment">// string literal per https://v8.dev/blog/cost-of-javascript-2019#json,</span><br><span class="token comment">// escaping special characters like `"` in the data.</span><br><span class="token comment">// Thanks to JSON âŠ‚ ECMAScript, the output of `JSON.stringify` is</span><br><span class="token comment">// guaranteed to be a syntactically valid ECMAScript literal:</span><br><span class="token keyword">const</span> jsStringLiteral <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Create a valid ECMAScript program that embeds the JavaScript string</span><br><span class="token comment">// literal representing the JSON data within a `JSON.parse` call.</span><br><span class="token keyword">const</span> program <span class="token operator">=</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">const data = JSON.parse(</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> jsStringLiteral <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">);</span><span class="token string template-punctuation">`</span></span><span class="token punctuation">;</span><br><span class="token comment">// â†’ 'const data = JSON.parse("â€¦");'</span><br><span class="token comment">// (Additional escaping is needed if the target is an inline &lt;script>.)</span><br><br><span class="token comment">// Write a file containing the ECMAScript program to disk.</span><br><span class="token function">saveToDisk</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> program<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The above script produces the following code, which evaluates to an equivalent object:<pre class=language-js><code class=language-js><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"{\"LineTerminators\":\"\\n\\râ€¨â€©\"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href=https://github.com/GoogleChromeLabs/json-parse-benchmark>Googleâ€™s benchmark comparing <code>JSON.parse</code> with JavaScript object literals</a> leverages this technique in its build step. The Chrome DevTools â€œcopy as JSâ€ functionality has been <a href=https://chromium-review.googlesource.com/c/chromium/src/+/1464719/9/third_party/blink/renderer/devtools/front_end/elements/DOMPath.js>simplified significantly</a> by adopting a similar technique.<h2 id=security>A note on security <a href=#security class=bookmark>#</a></h2><p>JSON âŠ‚ ECMAScript reduces the mismatch between JSON and ECMAScript in the case of string literals specifically. Since string literals can occur within other JSON-supported data structures such as objects and arrays, it also addresses those cases, as the above code examples show.<p>However, U+2028 and U+2029 are still treated as line terminator characters in other parts of the ECMAScript grammar. This means there are still cases where itâ€™s unsafe to inject JSON into JavaScript programs. Consider this example, where a server injects some user-supplied content into an HTML response after running it through <code>JSON.stringify()</code>:<pre class=language-ejs><code class=language-ejs><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><br>  <span class="token comment">// Debug info:</span><br>  <span class="token comment">// User-Agent: <span class="token ejs language-ejs"><span class="token punctuation delimiter">&lt;%=</span><span class="token language-javascript"> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>ua<span class="token punctuation">)</span> </span><span class="token punctuation delimiter">%></span></span></span><br></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>Note that the result of <code>JSON.stringify</code> is injected into a single-line comment within the script.<p>When used like in the above example, <code>JSON.stringify()</code> is guaranteed to return a single line. The problem is that what constitutes a â€œsingle lineâ€ <a href="https://speakerdeck.com/mathiasbynens/hacking-with-unicode?slide=136">differs between JSON and ECMAScript</a>. If <code>ua</code> contains an unescaped U+2028 or U+2029 character, we break out of the single-line comment and execute the rest of <code>ua</code> as JavaScript source code:<pre class=language-html><code class=language-html><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><br>  <span class="token comment">// Debug info:</span><br>  <span class="token comment">// User-Agent: "User-supplied string&lt;U+2028>  alert('XSS');//"</span><br></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><br><span class="token comment">&lt;!-- â€¦is equivalent to: --></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><br>  <span class="token comment">// Debug info:</span><br>  <span class="token comment">// User-Agent: "User-supplied string</span><br>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'XSS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"</span><br></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><div class=note><p><strong>Note:</strong> In the above example, the raw unescaped U+2028 character is represented as <code>&lt;U+2028></code> to make it easier to follow.</div><p>JSON âŠ‚ ECMAScript doesnâ€™t help here, since it only impacts string literals â€” and in this case, <code>JSON.stringify</code>â€™s output is injected in a position where it does not produce a JavaScript string literal directly.<p>Unless special post-processing for those two characters is introduced, the above code snippet presents a cross-site scripting vulnerability (XSS)!<div class=note><p><strong>Note:</strong> Itâ€™s crucially important to post-process user-controlled input to escape any special character sequences, depending on the context. In this particular case, weâ€™re injecting into a <code>&lt;script></code> tag, so we must (also) <a href=https://mathiasbynens.be/notes/etago#recommendations>escape <code>&lt;/script</code>, <code>&lt;script</code>, and <code>&lt;!-â€‹-</code></a>.</div><h2 id=support>JSON âŠ‚ ECMAScript support <a href=#support class=bookmark>#</a></h2><ul class=feature-support><li class="environment has-support has-link"><a href=/blog/v8-release-66#json-ecmascript><span class="icon chrome">Chrome:</span> <span class=support>è‡ª <span class=version>66</span> ç‰ˆæœ¬å¼€å§‹æ”¯æŒ</span></a><li class="environment has-support"><span class="icon firefox">Firefox:</span> <span class=support>æ”¯æŒ</span><li class="environment has-support"><span class="icon safari">Safari:</span> <span class=support>æ”¯æŒ</span><li class="environment has-support"><span class="icon nodejs">Node.js:</span> <span class=support>è‡ª <span class=version>10</span> ç‰ˆæœ¬å¼€å§‹æ”¯æŒ</span><li class="environment has-support has-link"><a href=https://github.com/babel/babel/tree/master/packages/babel-plugin-proposal-json-strings><span class="icon babel">Babel:</span> <span class=support>æ”¯æŒ</span></a></ul><div class=feature-support-info><a href=/features/support>å…³äºç‰¹æ€§æ”¯æŒåˆ—è¡¨</a></div></div><footer><div><picture><source srcset="/_img/avatars/mathias-bynens.avif, /_img/avatars/mathias-bynens@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/mathias-bynens.jpg srcset="/_img/avatars/mathias-bynens@2x.jpg 2x" width=96></picture><p>ä½œè€…ï¼šMathias Bynens (<a href=https://twitter.com/mathias>@mathias</a>).</div><a href=https://twitter.com/v8js/status/1161649929904885762 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/features/subsume-json>åŸæ–‡</a> Â· <a href=/logo/ >å•†æ ‡</a> Â· <a href=/terms/ >æ¡æ¬¾</a> Â· <a href=https://policies.google.com/privacy/ >éšç§</a> Â· <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> Â· <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/features/subsume-json.md rel=nofollow>åœ¨ GitHub ç¼–è¾‘æ­¤é¡µé¢</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>å¦‚æ— ç‰¹æ®Šè¯´æ˜ï¼Œæ­¤ V8 é¡¹ç›®ä¸­ä½¿ç”¨åˆ°çš„æ‰€æœ‰ç¤ºä¾‹ä»£ç å‡åŸºäº <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> å‘å¸ƒã€‚é¡µé¢ä¸­çš„æ–‡å­—å†…å®¹é‡‡ç”¨ <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> è¿›è¡Œè®¸å¯ã€‚æ›´è¯¦ç»†çš„ä¿¡æ¯å¯ä»¥åœ¨ <a href=/terms#site-policies>ç«™ç‚¹ç­–ç•¥</a> ä¸­æ‰¾åˆ°ã€‚</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
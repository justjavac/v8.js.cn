<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Stack trace API · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="This document outlines V8’s JavaScript stack trace API." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li class=active><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><h1>Stack trace API</h1><p>All internal errors thrown in V8 capture a stack trace when they are created. This stack trace can be accessed from JavaScript through the non-standard <code>error.stack</code> property. V8 also has various hooks for controlling how stack traces are collected and formatted, and for allowing custom errors to also collect stack traces. This document outlines V8’s JavaScript stack trace API.<h2 id=basic-stack-traces>Basic stack traces <a href=#basic-stack-traces class=bookmark>#</a></h2><p>By default, almost all errors thrown by V8 have a <code>stack</code> property that holds the topmost 10 stack frames, formatted as a string. Here’s an example of a fully formatted stack trace:<pre><code>ReferenceError: FAIL is not defined
   at Constraint.execute (deltablue.js:525:2)
   at Constraint.recalculate (deltablue.js:424:21)
   at Planner.addPropagate (deltablue.js:701:6)
   at Constraint.satisfy (deltablue.js:184:15)
   at Planner.incrementalAdd (deltablue.js:591:21)
   at Constraint.addConstraint (deltablue.js:162:10)
   at Constraint.BinaryConstraint (deltablue.js:346:7)
   at Constraint.EqualityConstraint (deltablue.js:515:38)
   at chainTest (deltablue.js:807:6)
   at deltaBlue (deltablue.js:879:2)
</code></pre><p>The stack trace is collected when the error is created and is the same regardless of where or how many times the error is thrown. We collect 10 frames because it is usually enough to be useful but not so many that it has a noticeable negative performance impact. You can control how many stack frames are collected by setting the variable<pre class=language-js><code class=language-js>Error<span class="token punctuation">.</span>stackTraceLimit</code></pre><p>Setting it to <code>0</code> disables stack trace collection. Any finite integer value can be used as the maximum number of frames to collect. Setting it to <code>Infinity</code> means that all frames get collected. This variable only affects the current context; it has to be set explicitly for each context that needs a different value. (Note that what is known as a “context” in V8 terminology corresponds to a page or <code>&lt;iframe></code> in Google Chrome). To set a different default value that affects all contexts use the following V8 command-line flag:<pre class=language-bash><code class=language-bash>--stack-trace-limit <span class="token operator">&lt;</span>value<span class="token operator">></span></code></pre><p>To pass this flag to V8 when running Google Chrome, use:<pre class=language-bash><code class=language-bash>--js-flags<span class="token operator">=</span><span class="token string">'--stack-trace-limit &lt;value>'</span></code></pre><h2 id=async-stack-traces>Async stack traces <a href=#async-stack-traces class=bookmark>#</a></h2><p>The <code>--async-stack-traces</code> flag (turned on by default since <a href=https://v8.dev/blog/v8-release-73#async-stack-traces>V8 v7.3</a>) enables the new <a href=https://bit.ly/v8-zero-cost-async-stack-traces>zero-cost async stack traces</a>, which enriches the <code>stack</code> property of <code>Error</code> instances with async stack frames, i.e. <code>await</code> locations in the code. These async frames are marked with <code>async</code> in the <code>stack</code> string:<pre><code>ReferenceError: FAIL is not defined
    at bar (&lt;anonymous>)
    at async foo (&lt;anonymous>)
</code></pre><p>At the time of this writing, this functionality is limited to <code>await</code> locations, <code>Promise.all()</code> and <code>Promise.any()</code>, since for those cases the engine can reconstruct the necessary information without any additional overhead (that’s why it’s zero-cost).<h2 id=stack-trace-collection-for-custom-exceptions>Stack trace collection for custom exceptions <a href=#stack-trace-collection-for-custom-exceptions class=bookmark>#</a></h2><p>The stack trace mechanism used for built-in errors is implemented using a general stack trace collection API that is also available to user scripts. The function<pre class=language-js><code class=language-js>Error<span class="token punctuation">.</span><span class="token function">captureStackTrace</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> constructorOpt<span class="token punctuation">)</span></code></pre><p>adds a stack property to the given <code>error</code> object that yields the stack trace at the time <code>captureStackTrace</code> was called. Stack traces collected through <code>Error.captureStackTrace</code> are immediately collected, formatted, and attached to the given <code>error</code> object.<p>The optional <code>constructorOpt</code> parameter allows you to pass in a function value. When collecting the stack trace all frames above the topmost call to this function, including that call, are left out of the stack trace. This can be useful to hide implementation details that won’t be useful to the user. The usual way of defining a custom error that captures a stack trace would be:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">MyError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  Error<span class="token punctuation">.</span><span class="token function">captureStackTrace</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MyError<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Any other initialization goes here.</span><br><span class="token punctuation">}</span></code></pre><p>Passing in MyError as a second argument means that the constructor call to MyError won’t show up in the stack trace.<h2 id=customizing-stack-traces>Customizing stack traces <a href=#customizing-stack-traces class=bookmark>#</a></h2><p>Unlike Java where the stack trace of an exception is a structured value that allows inspection of the stack state, the stack property in V8 just holds a flat string containing the formatted stack trace. This is for no other reason than compatibility with other browsers. However, this is not hardcoded but only the default behavior and can be overridden by user scripts.<p>For efficiency stack traces are not formatted when they are captured but on demand, the first time the stack property is accessed. A stack trace is formatted by calling<pre class=language-js><code class=language-js>Error<span class="token punctuation">.</span><span class="token function">prepareStackTrace</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> structuredStackTrace<span class="token punctuation">)</span></code></pre><p>and using whatever this call returns as the value of the <code>stack</code> property. If you assign a different function value to <code>Error.prepareStackTrace</code> that function is used to format stack traces. It gets passed the error object that it is preparing a stack trace for, as well as a structured representation of the stack. User stack trace formatters are free to format the stack trace however they want and even return non-string values. It is safe to retain references to the structured stack trace object after a call to <code>prepareStackTrace</code> completes so that it is also a valid return value. Note that the custom <code>prepareStackTrace</code> function is only called once the stack property of <code>Error</code> object is accessed.<p>The structured stack trace is an array of <code>CallSite</code> objects, each of which represents a stack frame. A <code>CallSite</code> object defines the following methods<ul><li><code>getThis</code>: returns the value of <code>this</code><li><code>getTypeName</code>: returns the type of <code>this</code> as a string. This is the name of the function stored in the constructor field of <code>this</code>, if available, otherwise the object’s <code>[[Class]]</code> internal property.<li><code>getFunction</code>: returns the current function<li><code>getFunctionName</code>: returns the name of the current function, typically its <code>name</code> property. If a <code>name</code> property is not available an attempt is made to infer a name from the function’s context.<li><code>getMethodName</code>: returns the name of the property of <code>this</code> or one of its prototypes that holds the current function<li><code>getFileName</code>: if this function was defined in a script returns the name of the script<li><code>getLineNumber</code>: if this function was defined in a script returns the current line number<li><code>getColumnNumber</code>: if this function was defined in a script returns the current column number<li><code>getEvalOrigin</code>: if this function was created using a call to <code>eval</code> returns a string representing the location where <code>eval</code> was called<li><code>isToplevel</code>: is this a top-level invocation, that is, is this the global object?<li><code>isEval</code>: does this call take place in code defined by a call to <code>eval</code>?<li><code>isNative</code>: is this call in native V8 code?<li><code>isConstructor</code>: is this a constructor call?<li><code>isAsync</code>: is this an async call (i.e. <code>await</code>, <code>Promise.all()</code>, or <code>Promise.any()</code>)?<li><code>isPromiseAll</code>: is this an async call to <code>Promise.all()</code>?<li><code>isPromiseAny</code>: is this an async call to <code>Promise.any()</code>?<li><code>getPromiseIndex</code>: returns the index of the promise element that was followed in <code>Promise.all()</code> or <code>Promise.any()</code> for async stack traces, or <code>null</code> if the <code>CallSite</code> is not an async <code>Promise.all()</code> or <code>Promise.any()</code> call.</ul><p>The default stack trace is created using the CallSite API so any information that is available there is also available through this API.<p>To maintain restrictions imposed on strict mode functions, frames that have a strict mode function and all frames below (its caller etc.) are not allow to access their receiver and function objects. For those frames, <code>getFunction()</code> and <code>getThis()</code> returns <code>undefined</code>.<h2 id=compatibility>Compatibility <a href=#compatibility class=bookmark>#</a></h2><p>The API described here is specific to V8 and is not supported by any other JavaScript implementations. Most implementations do provide an <code>error.stack</code> property but the format of the stack trace is likely to be different from the format described here. The recommended use of this API is:<ul><li>Only rely on the layout of the formatted stack trace if you know your code is running in v8.<li>It is safe to set <code>Error.stackTraceLimit</code> and <code>Error.prepareStackTrace</code> regardless of which implementation is running your code but be aware that it only has an effect if your code is running in V8.</ul><h2 id=appendix%3A-stack-trace-format>Appendix: Stack trace format <a href=#appendix%3A-stack-trace-format class=bookmark>#</a></h2><p>The default stack trace format used by V8 can for each stack frame give the following information:<ul><li>Whether the call is a construct call.<li>The type of the <code>this</code> value (<code>Type</code>).<li>The name of the function called (<code>functionName</code>).<li>The name of the property of this or one of its prototypes that holds the function (<code>methodName</code>).<li>The current location within the source (<code>location</code>)</ul><p>Any of these may be unavailable and different formats for stack frames are used depending on how much of this information is available. If all the above information is available a formatted stack frame looks like this:<pre><code>at Type.functionName [as methodName] (location)
</code></pre><p>Or, in the case of a construct call:<pre><code>at new functionName (location)
</code></pre><p>Or, in case of an async call:<pre><code>at async functionName (location)
</code></pre><p>If only one of <code>functionName</code> and <code>methodName</code> is available, or if they are both available but the same, the format is:<pre><code>at Type.name (location)
</code></pre><p>If neither is available <code>&lt;anonymous></code> is used as the name.<p>The <code>Type</code> value is the name of the function stored in the constructor field of <code>this</code>. In V8, all constructor calls set this property to the constructor function so unless this field has been actively changed after the object was created it, it holds the name of the function it was created by. If it is unavailable the <code>[[Class]]</code> property of the object is used.<p>One special case is the global object where the <code>Type</code> is not shown. In that case the stack frame is formatted as:<pre><code>at functionName [as methodName] (location)
</code></pre><p>The location itself has several possible formats. Most common is the file name, line and column number within the script that defined the current function:<pre><code>fileName:lineNumber:columnNumber
</code></pre><p>If the current function was created using <code>eval</code> the format is:<pre><code>eval at position
</code></pre><p>…where <code>position</code> is the full position where the call to <code>eval</code> occurred. Note that this means that positions can be nested if there are nested calls to <code>eval</code>, for instance:<pre><code>eval at Foo.a (eval at Bar.z (myscript.js:10:3))
</code></pre><p>If a stack frame is within V8’s libraries the location is:<pre><code>native
</code></pre><p>…and if is unavailable, it’s:<pre><code>unknown location
</code></pre></main><footer id=footer><div><nav><a href=https://v8.dev/docs/stack-trace-api>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/docs/stack-trace-api.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>
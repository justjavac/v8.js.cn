<!doctype html><html lang=zh-CN><meta charset=utf-8><title>WebAssembly compilation pipeline · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="This article explains V8’s WebAssembly compilers and when they compile WebAssembly code." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li class=active><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><h1>WebAssembly compilation pipeline</h1><p>WebAssembly is a binary format that allows you to run code from programming languages other than JavaScript on the web efficiently and securely. In this document we dive into the WebAssembly compilation pipeline in V8 and explain how we use the different compilers to provide good performance.<h2 id=liftoff>Liftoff <a href=#liftoff class=bookmark>#</a></h2><p>V8 first compiles a WebAssembly module with its baseline compiler, <a href=/blog/liftoff>Liftoff</a>. Liftoff is a <a href=https://en.wikipedia.org/wiki/One-pass_compiler>one-pass compiler</a>, which means it iterates over the WebAssembly code once and emits machine code immediately for each WebAssembly instruction. One-pass compilers excel at fast code generation, but can only apply a small set of optimizations. Indeed, Liftoff can compile WebAssembly code very fast, 10s of megabytes per second. Once Liftoff compilation is finished, the compiled WebAssembly module is returned to JavaScript.<h2 id=turbofan>TurboFan <a href=#turbofan class=bookmark>#</a></h2><p>Liftoff emits decently fast machine code in a very short period of time. However, because it emits code for each WebAssembly instruction independently, there is very little room for optimizations, like improving register allocations or common compiler optimizations like redundant load elimination, strength reduction, or function inlining.<p>This is why, as soon as Liftoff compilation is finished, V8 immediately starts to "tier up" the module by recompiling all functions with <a href=/docs/turbofan>TurboFan</a>, the optimizing compiler in V8 for both WebAssembly and JavaScript. TurboFan is a <a href=https://en.wikipedia.org/wiki/Multi-pass_compiler>multi-pass compiler</a>, which means that it builds multiple internal representations of the compiled code before emitting machine code. These additional internal representations allow optimizations and better register allocations, resulting in significantly faster code.<p>TurboFan compiles the WebAssembly module function by function. As soon as one function finishes, it immediately replaces the function compiled by Liftoff. Any new calls to that function will then use the new, optimized code produced by TurboFan, not the Liftoff code. Note though that we don’t do on-stack-replacement. This means that if TurboFan finishes optimizing a function that was already invoked when only the Liftoff version was available, it will finish its execution using the Liftoff version.<h2 id=code-caching>Code caching <a href=#code-caching class=bookmark>#</a></h2><p>If the WebAssembly module was compiled with <code>WebAssembly.compileStreaming</code>, then the TurboFan-generated machine code will also get cached. When the same WebAssembly module is fetched again from the same URL, the module is not compiled but loaded from cache. More information about code caching is available <a href=/blog/wasm-code-caching>in a separate blog post</a>.<h2 id=debugging>Debugging <a href=#debugging class=bookmark>#</a></h2><p>As mentioned earlier, TurboFan applies optimizations, many of which involve re-ordering code, eliminating variables or even skipping whole sections of code. This means that if you want to set a breakpoint at a specific instruction, it might not be clear where program execution should actually stop. In other words, TurboFan code is not well suited for debugging. Therefore, when debugging is started by opening DevTools, all TurboFan code is replaced by Liftoff code again ("tiered down"), as each WebAssembly instruction maps to exactly one section of machine code and all local and global variables are intact.<h2 id=profiling>Profiling <a href=#profiling class=bookmark>#</a></h2><p>To make things a bit more confusing, within DevTools all code will get tiered up (recompiled with TurboFan) again when the Performance tab is opened and the "Record" button in clicked. The "Record" button starts performance profiling. Profiling the Liftoff code would not be representative as it is only used while TurboFan isn’t finished and can be significantly slower than TurboFan’s output, which will be running for the vast majority of time.<h2 id=flags-for-experimentation>Flags for experimentation <a href=#flags-for-experimentation class=bookmark>#</a></h2><p>For experimentation, V8 and Chrome can be configured to compile WebAssembly code only with Liftoff or only with TurboFan. It is even possible to experiment with lazy compilation, where functions only get compiled when they get called for the first time. The following flags enable these experimental modes:<ul><li><p>Liftoff only:<ul><li>In V8, set the <code>--liftoff --no-wasm-tier-up</code> flags.<li>In Chrome, disable WebAssembly tiering (<code>chrome://flags/#enable-webassembly-tiering</code>) and enable WebAssembly baseline compiler (<code>chrome://flags/#enable-webassembly-baseline</code>).</ul><li><p>TurboFan only:<ul><li>In V8, set the <code>--no-liftoff --no-wasm-tier-up</code> flags.<li>In Chrome, disable WebAssembly tiering (<code>chrome://flags/#enable-webassembly-tiering</code>) and disable WebAssembly baseline compiler (<code>chrome://flags/#enable-webassembly-baseline</code>).</ul><li><p>Lazy compilation:<ul><li>Lazy compilation is a compilation mode where a function is only compiled when it is called for the first time. Similar to the production configuration the function is first compiled with Liftoff (blocking execution). After Liftoff compilation finishes, the function gets recompiled with TurboFan in the background.<li>In V8, set the <code>--wasm-lazy-compilation</code> flag.<li>In Chrome, enable WebAssembly lazy compilation (<code>chrome://flags/#enable-webassembly-lazy-compilation</code>).</ul></ul><h2 id=compile-time>Compile time <a href=#compile-time class=bookmark>#</a></h2><p>There are different ways to measure the compilation time of Liftoff and TurboFan. In the production configuration of V8, the compilation time of Liftoff can be measured from JavaScript by measuring the time it takes for <code>new WebAssembly.Module()</code> to finish, or the time it takes <code>WebAssembly.compile()</code> to resolve the promise. To measure the compilation time of TurboFan, one can do the same in a TurboFan-only configuration.<figure><img alt="" height=645 loading=lazy src=/_img/wasm-compilation-pipeline/trace.svg width=1012><figcaption>The trace for WebAssembly compilation in <a href=https://earth.google.com/web>Google Earth</a>.</figcaption></figure><p>The compilation can also be measured in more detail in <code>chrome://tracing/</code> by enabling the <code>v8.wasm</code> category. Liftoff compilation is then the time spent from starting the compilation until the <code>wasm.BaselineFinished</code> event, TurboFan compilation ends at the <code>wasm.TopTierFinished</code> event. Compilation itself starts at the <code>wasm.StartStreamingCompilation</code> event for <code>WebAssembly.compileStreaming()</code>, at the <code>wasm.SyncCompile</code> event for <code>new WebAssembly.Module()</code>, and at the <code>wasm.AsyncCompile</code> event for <code>WebAssembly.compile()</code>, respectively. Liftoff compilation is indicated with <code>wasm.BaselineCompilation</code> events, TurboFan compilation with <code>wasm.TopTierCompilation</code> events. The figure above shows the trace recorded for Google Earth, with the key events being highlighted.<p>More detailed tracing data is available with the <code>v8.wasm.detailed</code> category, which, among other information, provides the compilation time of single functions.</main><footer id=footer><div><nav><a href=https://v8.dev/docs/wasm-compilation-pipeline>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/docs/wasm-compilation-pipeline.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>